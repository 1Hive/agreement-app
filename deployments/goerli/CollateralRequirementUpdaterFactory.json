{
  "address": "0x03bA12E20494B9bf1805BE207272De459d034B1b",
  "abi": [
    {
      "constant": false,
      "inputs": [
        {
          "name": "_agreement",
          "type": "address"
        },
        {
          "name": "_disputableApps",
          "type": "address[]"
        },
        {
          "name": "_collateralTokens",
          "type": "address[]"
        },
        {
          "name": "_actionAmountsStable",
          "type": "uint256[]"
        },
        {
          "name": "_challengeAmountsStable",
          "type": "uint256[]"
        },
        {
          "name": "_priceOracle",
          "type": "address"
        },
        {
          "name": "_stableToken",
          "type": "address"
        }
      ],
      "name": "newCollateralRequirementUpdater",
      "outputs": [
        {
          "name": "",
          "type": "address"
        }
      ],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "name": "_newCollateralRequirementUpdater",
          "type": "address"
        }
      ],
      "name": "NewCollateralRequirementUpdater",
      "type": "event"
    }
  ],
  "transactionHash": "0xb77a4c6c273ca60e28722a51e88ca34b4267ab7f7a118d78bed620ed803c4cea",
  "receipt": {
    "to": null,
    "from": "0x2F9e113434aeBDd70bB99cB6505e1F726C578D6d",
    "contractAddress": "0x03bA12E20494B9bf1805BE207272De459d034B1b",
    "transactionIndex": 57,
    "gasUsed": "1146921",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x169e204eb1dda846e5ed094745179c085352a61d029d372e3870f1db1212b676",
    "transactionHash": "0xb77a4c6c273ca60e28722a51e88ca34b4267ab7f7a118d78bed620ed803c4cea",
    "logs": [],
    "blockNumber": 8301465,
    "cumulativeGasUsed": "9286448",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "f7407e4e08d726f80a955bcd3a6cc2ae",
  "metadata": "{\"compiler\":{\"version\":\"0.4.24+commit.e67f0147\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"constant\":false,\"inputs\":[{\"name\":\"_agreement\",\"type\":\"address\"},{\"name\":\"_disputableApps\",\"type\":\"address[]\"},{\"name\":\"_collateralTokens\",\"type\":\"address[]\"},{\"name\":\"_actionAmountsStable\",\"type\":\"uint256[]\"},{\"name\":\"_challengeAmountsStable\",\"type\":\"uint256[]\"},{\"name\":\"_priceOracle\",\"type\":\"address\"},{\"name\":\"_stableToken\",\"type\":\"address\"}],\"name\":\"newCollateralRequirementUpdater\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newCollateralRequirementUpdater\",\"type\":\"address\"}],\"name\":\"NewCollateralRequirementUpdater\",\"type\":\"event\"}],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"contracts/collateralUpdater/CollateralRequirementUpdaterFactory.sol\":\"CollateralRequirementUpdaterFactory\"},\"evmVersion\":\"byzantium\",\"libraries\":{},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[]},\"sources\":{\"@aragon/os/contracts/acl/ACLSyntaxSugar.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\n\\ncontract ACLSyntaxSugar {\\n    function arr() internal pure returns (uint256[]) {\\n        return new uint256[](0);\\n    }\\n\\n    function arr(bytes32 _a) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a));\\n    }\\n\\n    function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a), uint256(_b));\\n    }\\n\\n    function arr(address _a) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a));\\n    }\\n\\n    function arr(address _a, address _b) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a), uint256(_b));\\n    }\\n\\n    function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a), _b, _c);\\n    }\\n\\n    function arr(address _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a), _b, _c, _d);\\n    }\\n\\n    function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a), uint256(_b));\\n    }\\n\\n    function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a), uint256(_b), _c, _d, _e);\\n    }\\n\\n    function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a), uint256(_b), uint256(_c));\\n    }\\n\\n    function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a), uint256(_b), uint256(_c));\\n    }\\n\\n    function arr(uint256 _a) internal pure returns (uint256[] r) {\\n        r = new uint256[](1);\\n        r[0] = _a;\\n    }\\n\\n    function arr(uint256 _a, uint256 _b) internal pure returns (uint256[] r) {\\n        r = new uint256[](2);\\n        r[0] = _a;\\n        r[1] = _b;\\n    }\\n\\n    function arr(uint256 _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\\n        r = new uint256[](3);\\n        r[0] = _a;\\n        r[1] = _b;\\n        r[2] = _c;\\n    }\\n\\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\\n        r = new uint256[](4);\\n        r[0] = _a;\\n        r[1] = _b;\\n        r[2] = _c;\\n        r[3] = _d;\\n    }\\n\\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\\n        r = new uint256[](5);\\n        r[0] = _a;\\n        r[1] = _b;\\n        r[2] = _c;\\n        r[3] = _d;\\n        r[4] = _e;\\n    }\\n}\\n\\n\\ncontract ACLHelpers {\\n    function decodeParamOp(uint256 _x) internal pure returns (uint8 b) {\\n        return uint8(_x >> (8 * 30));\\n    }\\n\\n    function decodeParamId(uint256 _x) internal pure returns (uint8 b) {\\n        return uint8(_x >> (8 * 31));\\n    }\\n\\n    function decodeParamsList(uint256 _x) internal pure returns (uint32 a, uint32 b, uint32 c) {\\n        a = uint32(_x);\\n        b = uint32(_x >> (8 * 4));\\n        c = uint32(_x >> (8 * 8));\\n    }\\n}\\n\",\"keccak256\":\"0x672a96975fc17f66905e775645cc93249426ce9601aef597a13d1e449c7f89d0\"},\"@aragon/os/contracts/acl/IACL.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\n\\ninterface IACL {\\n    function initialize(address permissionsCreator) external;\\n\\n    // TODO: this should be external\\n    // See https://github.com/ethereum/solidity/issues/4832\\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\\n}\\n\",\"keccak256\":\"0x7e081f42891bbcc8fa9f3a67efb34ecafa8e2c075e37a01d74d221c45ddfdd10\"},\"@aragon/os/contracts/acl/IACLOracle.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\n\\ninterface IACLOracle {\\n    function canPerform(address who, address where, bytes32 what, uint256[] how) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x76b78ed68eafa0e3c9a4a9e4151f136f13dbcca0ac65cc43501db7b6a1189867\"},\"@aragon/os/contracts/apps/AppStorage.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./IAragonApp.sol\\\";\\nimport \\\"../common/UnstructuredStorage.sol\\\";\\nimport \\\"../kernel/IKernel.sol\\\";\\n\\n\\ncontract AppStorage is IAragonApp {\\n    using UnstructuredStorage for bytes32;\\n\\n    /* Hardcoded constants to save gas\\n    bytes32 internal constant KERNEL_POSITION = keccak256(\\\"aragonOS.appStorage.kernel\\\");\\n    bytes32 internal constant APP_ID_POSITION = keccak256(\\\"aragonOS.appStorage.appId\\\");\\n    */\\n    bytes32 internal constant KERNEL_POSITION = 0x4172f0f7d2289153072b0a6ca36959e0cbe2efc3afe50fc81636caa96338137b;\\n    bytes32 internal constant APP_ID_POSITION = 0xd625496217aa6a3453eecb9c3489dc5a53e6c67b444329ea2b2cbc9ff547639b;\\n\\n    function kernel() public view returns (IKernel) {\\n        return IKernel(KERNEL_POSITION.getStorageAddress());\\n    }\\n\\n    function appId() public view returns (bytes32) {\\n        return APP_ID_POSITION.getStorageBytes32();\\n    }\\n\\n    function setKernel(IKernel _kernel) internal {\\n        KERNEL_POSITION.setStorageAddress(address(_kernel));\\n    }\\n\\n    function setAppId(bytes32 _appId) internal {\\n        APP_ID_POSITION.setStorageBytes32(_appId);\\n    }\\n}\\n\",\"keccak256\":\"0x57f490644a5acb26fca0b4cb2cc7f52e64b0dbe9ca5d111f7c1b4e5250ed93ad\"},\"@aragon/os/contracts/apps/AragonApp.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./AppStorage.sol\\\";\\nimport \\\"../acl/ACLSyntaxSugar.sol\\\";\\nimport \\\"../common/Autopetrified.sol\\\";\\nimport \\\"../common/ConversionHelpers.sol\\\";\\nimport \\\"../common/ReentrancyGuard.sol\\\";\\nimport \\\"../common/VaultRecoverable.sol\\\";\\nimport \\\"../evmscript/EVMScriptRunner.sol\\\";\\nimport \\\"../lib/standards/ERC165.sol\\\";\\n\\n\\n// Contracts inheriting from AragonApp are, by default, immediately petrified upon deployment so\\n// that they can never be initialized.\\n// Unless overriden, this behaviour enforces those contracts to be usable only behind an AppProxy.\\n// ReentrancyGuard, EVMScriptRunner, and ACLSyntaxSugar are not directly used by this contract, but\\n// are included so that they are automatically usable by subclassing contracts\\ncontract AragonApp is ERC165, AppStorage, Autopetrified, VaultRecoverable, ReentrancyGuard, EVMScriptRunner, ACLSyntaxSugar {\\n    string private constant ERROR_AUTH_FAILED = \\\"APP_AUTH_FAILED\\\";\\n\\n    modifier auth(bytes32 _role) {\\n        require(canPerform(msg.sender, _role, new uint256[](0)), ERROR_AUTH_FAILED);\\n        _;\\n    }\\n\\n    modifier authP(bytes32 _role, uint256[] _params) {\\n        require(canPerform(msg.sender, _role, _params), ERROR_AUTH_FAILED);\\n        _;\\n    }\\n\\n    /**\\n    * @dev Check whether an action can be performed by a sender for a particular role on this app\\n    * @param _sender Sender of the call\\n    * @param _role Role on this app\\n    * @param _params Permission params for the role\\n    * @return Boolean indicating whether the sender has the permissions to perform the action.\\n    *         Always returns false if the app hasn't been initialized yet.\\n    */\\n    function canPerform(address _sender, bytes32 _role, uint256[] _params) public view returns (bool) {\\n        if (!hasInitialized()) {\\n            return false;\\n        }\\n\\n        IKernel linkedKernel = kernel();\\n        if (address(linkedKernel) == address(0)) {\\n            return false;\\n        }\\n\\n        return linkedKernel.hasPermission(\\n            _sender,\\n            address(this),\\n            _role,\\n            ConversionHelpers.dangerouslyCastUintArrayToBytes(_params)\\n        );\\n    }\\n\\n    /**\\n    * @dev Get the recovery vault for the app\\n    * @return Recovery vault address for the app\\n    */\\n    function getRecoveryVault() public view returns (address) {\\n        // Funds recovery via a vault is only available when used with a kernel\\n        return kernel().getRecoveryVault(); // if kernel is not set, it will revert\\n    }\\n\\n    /**\\n    * @dev Query if a contract implements a certain interface\\n    * @param _interfaceId The interface identifier being queried, as specified in ERC-165\\n    * @return True if the contract implements the requested interface and if its not 0xffffffff, false otherwise\\n    */\\n    function supportsInterface(bytes4 _interfaceId) public pure returns (bool) {\\n        return super.supportsInterface(_interfaceId) || _interfaceId == ARAGON_APP_INTERFACE_ID;\\n    }\\n}\\n\",\"keccak256\":\"0xa6c2ed08d7df92bf791ff85ecc9e400a874acfa6a7d961fa07e9175fb77231f4\"},\"@aragon/os/contracts/apps/IAragonApp.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"../kernel/IKernel.sol\\\";\\n\\n\\ncontract IAragonApp {\\n    // Includes appId and kernel methods:\\n    bytes4 internal constant ARAGON_APP_INTERFACE_ID = bytes4(0x54053e6c);\\n\\n    function kernel() public view returns (IKernel);\\n    function appId() public view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xdf64e62d609623a151c233b5f473f385117d68172aa2bf1ac4dc5cd8c5a3fc5b\"},\"@aragon/os/contracts/apps/disputable/DisputableAragonApp.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./IAgreement.sol\\\";\\nimport \\\"./IDisputable.sol\\\";\\nimport \\\"../AragonApp.sol\\\";\\nimport \\\"../../lib/math/SafeMath64.sol\\\";\\nimport \\\"../../lib/token/ERC20.sol\\\";\\n\\n\\ncontract DisputableAragonApp is IDisputable, AragonApp {\\n    /* Validation errors */\\n    string internal constant ERROR_SENDER_NOT_AGREEMENT = \\\"DISPUTABLE_SENDER_NOT_AGREEMENT\\\";\\n    string internal constant ERROR_AGREEMENT_STATE_INVALID = \\\"DISPUTABLE_AGREEMENT_STATE_INVAL\\\";\\n\\n    // This role is used to protect who can challenge actions in derived Disputable apps. However, it is not required\\n    // to be validated in the app itself as the connected Agreement is responsible for performing the check on a challenge.\\n    // bytes32 public constant CHALLENGE_ROLE = keccak256(\\\"CHALLENGE_ROLE\\\");\\n    bytes32 public constant CHALLENGE_ROLE = 0xef025787d7cd1a96d9014b8dc7b44899b8c1350859fb9e1e05f5a546dd65158d;\\n\\n    // bytes32 public constant SET_AGREEMENT_ROLE = keccak256(\\\"SET_AGREEMENT_ROLE\\\");\\n    bytes32 public constant SET_AGREEMENT_ROLE = 0x8dad640ab1b088990c972676ada708447affc660890ec9fc9a5483241c49f036;\\n\\n    // bytes32 internal constant AGREEMENT_POSITION = keccak256(\\\"aragonOS.appStorage.agreement\\\");\\n    bytes32 internal constant AGREEMENT_POSITION = 0x6dbe80ccdeafbf5f3fff5738b224414f85e9370da36f61bf21c65159df7409e9;\\n\\n    modifier onlyAgreement() {\\n        require(address(_getAgreement()) == msg.sender, ERROR_SENDER_NOT_AGREEMENT);\\n        _;\\n    }\\n\\n    /**\\n    * @notice Challenge disputable action #`_disputableActionId`\\n    * @dev This hook must be implemented by Disputable apps. We provide a base implementation to ensure that the `onlyAgreement` modifier\\n    *      is included. Subclasses should implement the internal implementation of the hook.\\n    * @param _disputableActionId Identifier of the action to be challenged\\n    * @param _challengeId Identifier of the challenge in the context of the Agreement\\n    * @param _challenger Address that submitted the challenge\\n    */\\n    function onDisputableActionChallenged(uint256 _disputableActionId, uint256 _challengeId, address _challenger) external onlyAgreement {\\n        _onDisputableActionChallenged(_disputableActionId, _challengeId, _challenger);\\n    }\\n\\n    /**\\n    * @notice Allow disputable action #`_disputableActionId`\\n    * @dev This hook must be implemented by Disputable apps. We provide a base implementation to ensure that the `onlyAgreement` modifier\\n    *      is included. Subclasses should implement the internal implementation of the hook.\\n    * @param _disputableActionId Identifier of the action to be allowed\\n    */\\n    function onDisputableActionAllowed(uint256 _disputableActionId) external onlyAgreement {\\n        _onDisputableActionAllowed(_disputableActionId);\\n    }\\n\\n    /**\\n    * @notice Reject disputable action #`_disputableActionId`\\n    * @dev This hook must be implemented by Disputable apps. We provide a base implementation to ensure that the `onlyAgreement` modifier\\n    *      is included. Subclasses should implement the internal implementation of the hook.\\n    * @param _disputableActionId Identifier of the action to be rejected\\n    */\\n    function onDisputableActionRejected(uint256 _disputableActionId) external onlyAgreement {\\n        _onDisputableActionRejected(_disputableActionId);\\n    }\\n\\n    /**\\n    * @notice Void disputable action #`_disputableActionId`\\n    * @dev This hook must be implemented by Disputable apps. We provide a base implementation to ensure that the `onlyAgreement` modifier\\n    *      is included. Subclasses should implement the internal implementation of the hook.\\n    * @param _disputableActionId Identifier of the action to be voided\\n    */\\n    function onDisputableActionVoided(uint256 _disputableActionId) external onlyAgreement {\\n        _onDisputableActionVoided(_disputableActionId);\\n    }\\n\\n    /**\\n    * @notice Set Agreement to `_agreement`\\n    * @param _agreement Agreement instance to be set\\n    */\\n    function setAgreement(IAgreement _agreement) external auth(SET_AGREEMENT_ROLE) {\\n        IAgreement agreement = _getAgreement();\\n        require(agreement == IAgreement(0) && _agreement != IAgreement(0), ERROR_AGREEMENT_STATE_INVALID);\\n\\n        AGREEMENT_POSITION.setStorageAddress(address(_agreement));\\n        emit AgreementSet(_agreement);\\n    }\\n\\n    /**\\n    * @dev Tell the linked Agreement\\n    * @return Agreement\\n    */\\n    function getAgreement() external view returns (IAgreement) {\\n        return _getAgreement();\\n    }\\n\\n    /**\\n    * @dev Query if a contract implements a certain interface\\n    * @param _interfaceId The interface identifier being queried, as specified in ERC-165\\n    * @return True if the contract implements the requested interface and if its not 0xffffffff, false otherwise\\n    */\\n    function supportsInterface(bytes4 _interfaceId) public pure returns (bool) {\\n        return super.supportsInterface(_interfaceId) || _interfaceId == DISPUTABLE_INTERFACE_ID;\\n    }\\n\\n    /**\\n    * @dev Internal implementation of the `onDisputableActionChallenged` hook\\n    * @param _disputableActionId Identifier of the action to be challenged\\n    * @param _challengeId Identifier of the challenge in the context of the Agreement\\n    * @param _challenger Address that submitted the challenge\\n    */\\n    function _onDisputableActionChallenged(uint256 _disputableActionId, uint256 _challengeId, address _challenger) internal;\\n\\n    /**\\n    * @dev Internal implementation of the `onDisputableActionRejected` hook\\n    * @param _disputableActionId Identifier of the action to be rejected\\n    */\\n    function _onDisputableActionRejected(uint256 _disputableActionId) internal;\\n\\n    /**\\n    * @dev Internal implementation of the `onDisputableActionAllowed` hook\\n    * @param _disputableActionId Identifier of the action to be allowed\\n    */\\n    function _onDisputableActionAllowed(uint256 _disputableActionId) internal;\\n\\n    /**\\n    * @dev Internal implementation of the `onDisputableActionVoided` hook\\n    * @param _disputableActionId Identifier of the action to be voided\\n    */\\n    function _onDisputableActionVoided(uint256 _disputableActionId) internal;\\n\\n    /**\\n    * @dev Register a new disputable action in the Agreement\\n    * @param _disputableActionId Identifier of the action in the context of the Disputable\\n    * @param _context Link to human-readable context for the given action\\n    * @param _submitter Address that submitted the action\\n    * @return Unique identifier for the created action in the context of the Agreement\\n    */\\n    function _registerDisputableAction(uint256 _disputableActionId, bytes _context, address _submitter) internal returns (uint256) {\\n        IAgreement agreement = _ensureAgreement();\\n        return agreement.newAction(_disputableActionId, _context, _submitter);\\n    }\\n\\n    /**\\n    * @dev Close disputable action in the Agreement\\n    * @param _actionId Identifier of the action in the context of the Agreement\\n    */\\n    function _closeDisputableAction(uint256 _actionId) internal {\\n        IAgreement agreement = _ensureAgreement();\\n        agreement.closeAction(_actionId);\\n    }\\n\\n    /**\\n    * @dev Tell the linked Agreement\\n    * @return Agreement\\n    */\\n    function _getAgreement() internal view returns (IAgreement) {\\n        return IAgreement(AGREEMENT_POSITION.getStorageAddress());\\n    }\\n\\n    /**\\n    * @dev Tell the linked Agreement or revert if it has not been set\\n    * @return Agreement\\n    */\\n    function _ensureAgreement() internal view returns (IAgreement) {\\n        IAgreement agreement = _getAgreement();\\n        require(agreement != IAgreement(0), ERROR_AGREEMENT_STATE_INVALID);\\n        return agreement;\\n    }\\n}\\n\",\"keccak256\":\"0x263599fea1510ae4c2b911afd3fb44ef4b0c6e8f75860f1269145482c7400053\"},\"@aragon/os/contracts/apps/disputable/IAgreement.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"../../lib/token/ERC20.sol\\\";\\n\\n\\ncontract IAgreement {\\n\\n    event ActionSubmitted(uint256 indexed actionId, address indexed disputable);\\n    event ActionClosed(uint256 indexed actionId);\\n    event ActionChallenged(uint256 indexed actionId, uint256 indexed challengeId);\\n    event ActionSettled(uint256 indexed actionId, uint256 indexed challengeId);\\n    event ActionDisputed(uint256 indexed actionId, uint256 indexed challengeId);\\n    event ActionAccepted(uint256 indexed actionId, uint256 indexed challengeId);\\n    event ActionVoided(uint256 indexed actionId, uint256 indexed challengeId);\\n    event ActionRejected(uint256 indexed actionId, uint256 indexed challengeId);\\n\\n    enum ChallengeState {\\n        Waiting,\\n        Settled,\\n        Disputed,\\n        Rejected,\\n        Accepted,\\n        Voided\\n    }\\n\\n    function newAction(uint256 _disputableActionId, bytes _context, address _submitter) external returns (uint256);\\n\\n    function closeAction(uint256 _actionId) external;\\n\\n    function challengeAction(uint256 _actionId, uint256 _settlementOffer, bool _finishedSubmittingEvidence, bytes _context) external;\\n\\n    function settleAction(uint256 _actionId) external;\\n\\n    function disputeAction(uint256 _actionId, bool _finishedSubmittingEvidence) external;\\n}\\n\",\"keccak256\":\"0xe8fa5edb52014934b90ceda4f7d8e191b5c164ebc5506189b56f0e183567f90f\"},\"@aragon/os/contracts/apps/disputable/IDisputable.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./IAgreement.sol\\\";\\nimport \\\"../../lib/standards/ERC165.sol\\\";\\nimport \\\"../../lib/token/ERC20.sol\\\";\\n\\n\\ncontract IDisputable is ERC165 {\\n    // Includes setAgreement, onDisputableActionChallenged, onDisputableActionAllowed,\\n    // onDisputableActionRejected, onDisputableActionVoided, getAgreement, canChallenge, and canClose methods:\\n    bytes4 internal constant DISPUTABLE_INTERFACE_ID = bytes4(0xf3d3bb51);\\n\\n    event AgreementSet(IAgreement indexed agreement);\\n\\n    function setAgreement(IAgreement _agreement) external;\\n\\n    function onDisputableActionChallenged(uint256 _disputableActionId, uint256 _challengeId, address _challenger) external;\\n\\n    function onDisputableActionAllowed(uint256 _disputableActionId) external;\\n\\n    function onDisputableActionRejected(uint256 _disputableActionId) external;\\n\\n    function onDisputableActionVoided(uint256 _disputableActionId) external;\\n\\n    function getAgreement() external view returns (IAgreement);\\n\\n    function canChallenge(uint256 _disputableActionId) external view returns (bool);\\n\\n    function canClose(uint256 _disputableActionId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xce0da286f2b52dc33c9846b101ff075ac9461881aaf1753058151d51b1d55436\"},\"@aragon/os/contracts/common/Autopetrified.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./Petrifiable.sol\\\";\\n\\n\\ncontract Autopetrified is Petrifiable {\\n    constructor() public {\\n        // Immediately petrify base (non-proxy) instances of inherited contracts on deploy.\\n        // This renders them uninitializable (and unusable without a proxy).\\n        petrify();\\n    }\\n}\\n\",\"keccak256\":\"0x42f0422744e13674e38bfbef079af7150883aba96ddbe61c5ae50df31d42696e\"},\"@aragon/os/contracts/common/ConversionHelpers.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n\\nlibrary ConversionHelpers {\\n    string private constant ERROR_IMPROPER_LENGTH = \\\"CONVERSION_IMPROPER_LENGTH\\\";\\n\\n    function dangerouslyCastUintArrayToBytes(uint256[] memory _input) internal pure returns (bytes memory output) {\\n        // Force cast the uint256[] into a bytes array, by overwriting its length\\n        // Note that the bytes array doesn't need to be initialized as we immediately overwrite it\\n        // with the input and a new length. The input becomes invalid from this point forward.\\n        uint256 byteLength = _input.length * 32;\\n        assembly {\\n            output := _input\\n            mstore(output, byteLength)\\n        }\\n    }\\n\\n    function dangerouslyCastBytesToUintArray(bytes memory _input) internal pure returns (uint256[] memory output) {\\n        // Force cast the bytes array into a uint256[], by overwriting its length\\n        // Note that the uint256[] doesn't need to be initialized as we immediately overwrite it\\n        // with the input and a new length. The input becomes invalid from this point forward.\\n        uint256 intsLength = _input.length / 32;\\n        require(_input.length == intsLength * 32, ERROR_IMPROPER_LENGTH);\\n\\n        assembly {\\n            output := _input\\n            mstore(output, intsLength)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9872383d458352f5c68fa5afd1fc84ab6b172cbee33359cfa57655b8eda92416\"},\"@aragon/os/contracts/common/EtherTokenConstant.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\n\\n// aragonOS and aragon-apps rely on address(0) to denote native ETH, in\\n// contracts where both tokens and ETH are accepted\\ncontract EtherTokenConstant {\\n    address internal constant ETH = address(0);\\n}\\n\",\"keccak256\":\"0x6b2fa091968161075154a77fa741a3484c891d73cd3cd14ede502ff56dd08dfc\"},\"@aragon/os/contracts/common/IVaultRecoverable.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\n\\ninterface IVaultRecoverable {\\n    event RecoverToVault(address indexed vault, address indexed token, uint256 amount);\\n\\n    function transferToVault(address token) external;\\n\\n    function allowRecoverability(address token) external view returns (bool);\\n    function getRecoveryVault() external view returns (address);\\n}\\n\",\"keccak256\":\"0xa8e004decf086e817a864b485473b687c2c468c82af7b5011d9908586f7cbf36\"},\"@aragon/os/contracts/common/Initializable.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./TimeHelpers.sol\\\";\\nimport \\\"./UnstructuredStorage.sol\\\";\\n\\n\\ncontract Initializable is TimeHelpers {\\n    using UnstructuredStorage for bytes32;\\n\\n    // keccak256(\\\"aragonOS.initializable.initializationBlock\\\")\\n    bytes32 internal constant INITIALIZATION_BLOCK_POSITION = 0xebb05b386a8d34882b8711d156f463690983dc47815980fb82aeeff1aa43579e;\\n\\n    string private constant ERROR_ALREADY_INITIALIZED = \\\"INIT_ALREADY_INITIALIZED\\\";\\n    string private constant ERROR_NOT_INITIALIZED = \\\"INIT_NOT_INITIALIZED\\\";\\n\\n    modifier onlyInit {\\n        require(getInitializationBlock() == 0, ERROR_ALREADY_INITIALIZED);\\n        _;\\n    }\\n\\n    modifier isInitialized {\\n        require(hasInitialized(), ERROR_NOT_INITIALIZED);\\n        _;\\n    }\\n\\n    /**\\n    * @return Block number in which the contract was initialized\\n    */\\n    function getInitializationBlock() public view returns (uint256) {\\n        return INITIALIZATION_BLOCK_POSITION.getStorageUint256();\\n    }\\n\\n    /**\\n    * @return Whether the contract has been initialized by the time of the current block\\n    */\\n    function hasInitialized() public view returns (bool) {\\n        uint256 initializationBlock = getInitializationBlock();\\n        return initializationBlock != 0 && getBlockNumber() >= initializationBlock;\\n    }\\n\\n    /**\\n    * @dev Function to be called by top level contract after initialization has finished.\\n    */\\n    function initialized() internal onlyInit {\\n        INITIALIZATION_BLOCK_POSITION.setStorageUint256(getBlockNumber());\\n    }\\n\\n    /**\\n    * @dev Function to be called by top level contract after initialization to enable the contract\\n    *      at a future block number rather than immediately.\\n    */\\n    function initializedAt(uint256 _blockNumber) internal onlyInit {\\n        INITIALIZATION_BLOCK_POSITION.setStorageUint256(_blockNumber);\\n    }\\n}\\n\",\"keccak256\":\"0xc859366d3143499d1458ea55cb5374ae1ca1faf41763cad5e051dea2da373ba1\"},\"@aragon/os/contracts/common/IsContract.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\n\\ncontract IsContract {\\n    /*\\n    * NOTE: this should NEVER be used for authentication\\n    * (see pitfalls: https://github.com/fergarrui/ethereum-security/tree/master/contracts/extcodesize).\\n    *\\n    * This is only intended to be used as a sanity check that an address is actually a contract,\\n    * RATHER THAN an address not being a contract.\\n    */\\n    function isContract(address _target) internal view returns (bool) {\\n        if (_target == address(0)) {\\n            return false;\\n        }\\n\\n        uint256 size;\\n        assembly { size := extcodesize(_target) }\\n        return size > 0;\\n    }\\n}\\n\",\"keccak256\":\"0x9dd99d770a5eed901ba749e1f02e4fae443e71e899f4909f56825dfc378da089\"},\"@aragon/os/contracts/common/Petrifiable.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./Initializable.sol\\\";\\n\\n\\ncontract Petrifiable is Initializable {\\n    // Use block UINT256_MAX (which should be never) as the initializable date\\n    uint256 internal constant PETRIFIED_BLOCK = uint256(-1);\\n\\n    function isPetrified() public view returns (bool) {\\n        return getInitializationBlock() == PETRIFIED_BLOCK;\\n    }\\n\\n    /**\\n    * @dev Function to be called by top level contract to prevent being initialized.\\n    *      Useful for freezing base contracts when they're used behind proxies.\\n    */\\n    function petrify() internal onlyInit {\\n        initializedAt(PETRIFIED_BLOCK);\\n    }\\n}\\n\",\"keccak256\":\"0x797d3a58b782032f6afc51725326c0b51dceb00f3af6b85b25bd91cc10d22504\"},\"@aragon/os/contracts/common/ReentrancyGuard.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"../common/UnstructuredStorage.sol\\\";\\n\\n\\ncontract ReentrancyGuard {\\n    using UnstructuredStorage for bytes32;\\n\\n    /* Hardcoded constants to save gas\\n    bytes32 internal constant REENTRANCY_MUTEX_POSITION = keccak256(\\\"aragonOS.reentrancyGuard.mutex\\\");\\n    */\\n    bytes32 private constant REENTRANCY_MUTEX_POSITION = 0xe855346402235fdd185c890e68d2c4ecad599b88587635ee285bce2fda58dacb;\\n\\n    string private constant ERROR_REENTRANT = \\\"REENTRANCY_REENTRANT_CALL\\\";\\n\\n    modifier nonReentrant() {\\n        // Ensure mutex is unlocked\\n        require(!REENTRANCY_MUTEX_POSITION.getStorageBool(), ERROR_REENTRANT);\\n\\n        // Lock mutex before function call\\n        REENTRANCY_MUTEX_POSITION.setStorageBool(true);\\n\\n        // Perform function call\\n        _;\\n\\n        // Unlock mutex after function call\\n        REENTRANCY_MUTEX_POSITION.setStorageBool(false);\\n    }\\n}\\n\",\"keccak256\":\"0xd89653c118bbd8cace423c45daa37986c566672198a415254011c028d1831189\"},\"@aragon/os/contracts/common/SafeERC20.sol\":{\"content\":\"// Inspired by AdEx (https://github.com/AdExNetwork/adex-protocol-eth/blob/b9df617829661a7518ee10f4cb6c4108659dd6d5/contracts/libs/SafeERC20.sol)\\n// and 0x (https://github.com/0xProject/0x-monorepo/blob/737d1dc54d72872e24abce5a1dbe1b66d35fa21a/contracts/protocol/contracts/protocol/AssetProxy/ERC20Proxy.sol#L143)\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"../lib/token/ERC20.sol\\\";\\n\\n\\nlibrary SafeERC20 {\\n    // Before 0.5, solidity has a mismatch between `address.transfer()` and `token.transfer()`:\\n    // https://github.com/ethereum/solidity/issues/3544\\n    bytes4 private constant TRANSFER_SELECTOR = 0xa9059cbb;\\n\\n    string private constant ERROR_TOKEN_BALANCE_REVERTED = \\\"SAFE_ERC_20_BALANCE_REVERTED\\\";\\n    string private constant ERROR_TOKEN_ALLOWANCE_REVERTED = \\\"SAFE_ERC_20_ALLOWANCE_REVERTED\\\";\\n\\n    function invokeAndCheckSuccess(address _addr, bytes memory _calldata)\\n        private\\n        returns (bool)\\n    {\\n        bool ret;\\n        assembly {\\n            let ptr := mload(0x40)    // free memory pointer\\n\\n            let success := call(\\n                gas,                  // forward all gas\\n                _addr,                // address\\n                0,                    // no value\\n                add(_calldata, 0x20), // calldata start\\n                mload(_calldata),     // calldata length\\n                ptr,                  // write output over free memory\\n                0x20                  // uint256 return\\n            )\\n\\n            if gt(success, 0) {\\n                // Check number of bytes returned from last function call\\n                switch returndatasize\\n\\n                // No bytes returned: assume success\\n                case 0 {\\n                    ret := 1\\n                }\\n\\n                // 32 bytes returned: check if non-zero\\n                case 0x20 {\\n                    // Only return success if returned data was true\\n                    // Already have output in ptr\\n                    ret := eq(mload(ptr), 1)\\n                }\\n\\n                // Not sure what was returned: don't mark as success\\n                default { }\\n            }\\n        }\\n        return ret;\\n    }\\n\\n    function staticInvoke(address _addr, bytes memory _calldata)\\n        private\\n        view\\n        returns (bool, uint256)\\n    {\\n        bool success;\\n        uint256 ret;\\n        assembly {\\n            let ptr := mload(0x40)    // free memory pointer\\n\\n            success := staticcall(\\n                gas,                  // forward all gas\\n                _addr,                // address\\n                add(_calldata, 0x20), // calldata start\\n                mload(_calldata),     // calldata length\\n                ptr,                  // write output over free memory\\n                0x20                  // uint256 return\\n            )\\n\\n            if gt(success, 0) {\\n                ret := mload(ptr)\\n            }\\n        }\\n        return (success, ret);\\n    }\\n\\n    /**\\n    * @dev Same as a standards-compliant ERC20.transfer() that never reverts (returns false).\\n    *      Note that this makes an external call to the token.\\n    */\\n    function safeTransfer(ERC20 _token, address _to, uint256 _amount) internal returns (bool) {\\n        bytes memory transferCallData = abi.encodeWithSelector(\\n            TRANSFER_SELECTOR,\\n            _to,\\n            _amount\\n        );\\n        return invokeAndCheckSuccess(_token, transferCallData);\\n    }\\n\\n    /**\\n    * @dev Same as a standards-compliant ERC20.transferFrom() that never reverts (returns false).\\n    *      Note that this makes an external call to the token.\\n    */\\n    function safeTransferFrom(ERC20 _token, address _from, address _to, uint256 _amount) internal returns (bool) {\\n        bytes memory transferFromCallData = abi.encodeWithSelector(\\n            _token.transferFrom.selector,\\n            _from,\\n            _to,\\n            _amount\\n        );\\n        return invokeAndCheckSuccess(_token, transferFromCallData);\\n    }\\n\\n    /**\\n    * @dev Same as a standards-compliant ERC20.approve() that never reverts (returns false).\\n    *      Note that this makes an external call to the token.\\n    */\\n    function safeApprove(ERC20 _token, address _spender, uint256 _amount) internal returns (bool) {\\n        bytes memory approveCallData = abi.encodeWithSelector(\\n            _token.approve.selector,\\n            _spender,\\n            _amount\\n        );\\n        return invokeAndCheckSuccess(_token, approveCallData);\\n    }\\n\\n    /**\\n    * @dev Static call into ERC20.balanceOf().\\n    * Reverts if the call fails for some reason (should never fail).\\n    */\\n    function staticBalanceOf(ERC20 _token, address _owner) internal view returns (uint256) {\\n        bytes memory balanceOfCallData = abi.encodeWithSelector(\\n            _token.balanceOf.selector,\\n            _owner\\n        );\\n\\n        (bool success, uint256 tokenBalance) = staticInvoke(_token, balanceOfCallData);\\n        require(success, ERROR_TOKEN_BALANCE_REVERTED);\\n\\n        return tokenBalance;\\n    }\\n\\n    /**\\n    * @dev Static call into ERC20.allowance().\\n    * Reverts if the call fails for some reason (should never fail).\\n    */\\n    function staticAllowance(ERC20 _token, address _owner, address _spender) internal view returns (uint256) {\\n        bytes memory allowanceCallData = abi.encodeWithSelector(\\n            _token.allowance.selector,\\n            _owner,\\n            _spender\\n        );\\n\\n        (bool success, uint256 allowance) = staticInvoke(_token, allowanceCallData);\\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\\n\\n        return allowance;\\n    }\\n\\n    /**\\n    * @dev Static call into ERC20.totalSupply().\\n    * Reverts if the call fails for some reason (should never fail).\\n    */\\n    function staticTotalSupply(ERC20 _token) internal view returns (uint256) {\\n        bytes memory totalSupplyCallData = abi.encodeWithSelector(_token.totalSupply.selector);\\n\\n        (bool success, uint256 totalSupply) = staticInvoke(_token, totalSupplyCallData);\\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\\n\\n        return totalSupply;\\n    }\\n}\\n\",\"keccak256\":\"0xd251a1207e1faa4c41500bf927310bb739b1fbc0bf880f236f8e0a9236d6a03a\"},\"@aragon/os/contracts/common/TimeHelpers.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./Uint256Helpers.sol\\\";\\n\\n\\ncontract TimeHelpers {\\n    using Uint256Helpers for uint256;\\n\\n    /**\\n    * @dev Returns the current block number.\\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\\n    *      tests.\\n    */\\n    function getBlockNumber() internal view returns (uint256) {\\n        return block.number;\\n    }\\n\\n    /**\\n    * @dev Returns the current block number, converted to uint64.\\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\\n    *      tests.\\n    */\\n    function getBlockNumber64() internal view returns (uint64) {\\n        return getBlockNumber().toUint64();\\n    }\\n\\n    /**\\n    * @dev Returns the current timestamp.\\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\\n    *      tests.\\n    */\\n    function getTimestamp() internal view returns (uint256) {\\n        return block.timestamp; // solium-disable-line security/no-block-members\\n    }\\n\\n    /**\\n    * @dev Returns the current timestamp, converted to uint64.\\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\\n    *      tests.\\n    */\\n    function getTimestamp64() internal view returns (uint64) {\\n        return getTimestamp().toUint64();\\n    }\\n}\\n\",\"keccak256\":\"0xfaba85207f0bb4bb5d7b6685a963c39a3258641bda6e523175640c3f9aeb2045\"},\"@aragon/os/contracts/common/Uint256Helpers.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n\\nlibrary Uint256Helpers {\\n    uint256 private constant MAX_UINT64 = uint64(-1);\\n\\n    string private constant ERROR_NUMBER_TOO_BIG = \\\"UINT64_NUMBER_TOO_BIG\\\";\\n\\n    function toUint64(uint256 a) internal pure returns (uint64) {\\n        require(a <= MAX_UINT64, ERROR_NUMBER_TOO_BIG);\\n        return uint64(a);\\n    }\\n}\\n\",\"keccak256\":\"0x83033025a3f4402be3b7bcc9a23ce96ae4fadc7f251da8f139d73a13a3400b0c\"},\"@aragon/os/contracts/common/UnstructuredStorage.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\n\\nlibrary UnstructuredStorage {\\n    function getStorageBool(bytes32 position) internal view returns (bool data) {\\n        assembly { data := sload(position) }\\n    }\\n\\n    function getStorageAddress(bytes32 position) internal view returns (address data) {\\n        assembly { data := sload(position) }\\n    }\\n\\n    function getStorageBytes32(bytes32 position) internal view returns (bytes32 data) {\\n        assembly { data := sload(position) }\\n    }\\n\\n    function getStorageUint256(bytes32 position) internal view returns (uint256 data) {\\n        assembly { data := sload(position) }\\n    }\\n\\n    function setStorageBool(bytes32 position, bool data) internal {\\n        assembly { sstore(position, data) }\\n    }\\n\\n    function setStorageAddress(bytes32 position, address data) internal {\\n        assembly { sstore(position, data) }\\n    }\\n\\n    function setStorageBytes32(bytes32 position, bytes32 data) internal {\\n        assembly { sstore(position, data) }\\n    }\\n\\n    function setStorageUint256(bytes32 position, uint256 data) internal {\\n        assembly { sstore(position, data) }\\n    }\\n}\\n\",\"keccak256\":\"0xe497dcb85bbbf10224623247f39a4aeed7d3b230de2a811f3b69cb0e7d0a64d4\"},\"@aragon/os/contracts/common/VaultRecoverable.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"../lib/token/ERC20.sol\\\";\\nimport \\\"./EtherTokenConstant.sol\\\";\\nimport \\\"./IsContract.sol\\\";\\nimport \\\"./IVaultRecoverable.sol\\\";\\nimport \\\"./SafeERC20.sol\\\";\\n\\n\\ncontract VaultRecoverable is IVaultRecoverable, EtherTokenConstant, IsContract {\\n    using SafeERC20 for ERC20;\\n\\n    string private constant ERROR_DISALLOWED = \\\"RECOVER_DISALLOWED\\\";\\n    string private constant ERROR_VAULT_NOT_CONTRACT = \\\"RECOVER_VAULT_NOT_CONTRACT\\\";\\n    string private constant ERROR_TOKEN_TRANSFER_FAILED = \\\"RECOVER_TOKEN_TRANSFER_FAILED\\\";\\n\\n    /**\\n     * @notice Send funds to recovery Vault. This contract should never receive funds,\\n     *         but in case it does, this function allows one to recover them.\\n     * @param _token Token balance to be sent to recovery vault.\\n     */\\n    function transferToVault(address _token) external {\\n        require(allowRecoverability(_token), ERROR_DISALLOWED);\\n        address vault = getRecoveryVault();\\n        require(isContract(vault), ERROR_VAULT_NOT_CONTRACT);\\n\\n        uint256 balance;\\n        if (_token == ETH) {\\n            balance = address(this).balance;\\n            vault.transfer(balance);\\n        } else {\\n            ERC20 token = ERC20(_token);\\n            balance = token.staticBalanceOf(this);\\n            require(token.safeTransfer(vault, balance), ERROR_TOKEN_TRANSFER_FAILED);\\n        }\\n\\n        emit RecoverToVault(vault, _token, balance);\\n    }\\n\\n    /**\\n    * @dev By default deriving from AragonApp makes it recoverable\\n    * @param token Token address that would be recovered\\n    * @return bool whether the app allows the recovery\\n    */\\n    function allowRecoverability(address token) public view returns (bool) {\\n        return true;\\n    }\\n\\n    // Cast non-implemented interface to be public so we can use it internally\\n    function getRecoveryVault() public view returns (address);\\n}\\n\",\"keccak256\":\"0xea4ded621a63f988b83ac27b4a23cad0a42c3d77bcf6ca7b88681ae4ea650cf4\"},\"@aragon/os/contracts/evmscript/EVMScriptRunner.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./IEVMScriptExecutor.sol\\\";\\nimport \\\"./IEVMScriptRegistry.sol\\\";\\n\\nimport \\\"../apps/AppStorage.sol\\\";\\nimport \\\"../kernel/KernelConstants.sol\\\";\\nimport \\\"../common/Initializable.sol\\\";\\n\\n\\ncontract EVMScriptRunner is AppStorage, Initializable, EVMScriptRegistryConstants, KernelNamespaceConstants {\\n    string private constant ERROR_EXECUTOR_UNAVAILABLE = \\\"EVMRUN_EXECUTOR_UNAVAILABLE\\\";\\n    string private constant ERROR_PROTECTED_STATE_MODIFIED = \\\"EVMRUN_PROTECTED_STATE_MODIFIED\\\";\\n\\n    /* This is manually crafted in assembly\\n    string private constant ERROR_EXECUTOR_INVALID_RETURN = \\\"EVMRUN_EXECUTOR_INVALID_RETURN\\\";\\n    */\\n\\n    event ScriptResult(address indexed executor, bytes script, bytes input, bytes returnData);\\n\\n    function getEVMScriptExecutor(bytes _script) public view returns (IEVMScriptExecutor) {\\n        return IEVMScriptExecutor(getEVMScriptRegistry().getScriptExecutor(_script));\\n    }\\n\\n    function getEVMScriptRegistry() public view returns (IEVMScriptRegistry) {\\n        address registryAddr = kernel().getApp(KERNEL_APP_ADDR_NAMESPACE, EVMSCRIPT_REGISTRY_APP_ID);\\n        return IEVMScriptRegistry(registryAddr);\\n    }\\n\\n    function runScript(bytes _script, bytes _input, address[] _blacklist)\\n        internal\\n        isInitialized\\n        protectState\\n        returns (bytes)\\n    {\\n        IEVMScriptExecutor executor = getEVMScriptExecutor(_script);\\n        require(address(executor) != address(0), ERROR_EXECUTOR_UNAVAILABLE);\\n\\n        bytes4 sig = executor.execScript.selector;\\n        bytes memory data = abi.encodeWithSelector(sig, _script, _input, _blacklist);\\n\\n        bytes memory output;\\n        assembly {\\n            let success := delegatecall(\\n                gas,                // forward all gas\\n                executor,           // address\\n                add(data, 0x20),    // calldata start\\n                mload(data),        // calldata length\\n                0,                  // don't write output (we'll handle this ourselves)\\n                0                   // don't write output\\n            )\\n\\n            output := mload(0x40) // free mem ptr get\\n\\n            switch success\\n            case 0 {\\n                // If the call errored, forward its full error data\\n                returndatacopy(output, 0, returndatasize)\\n                revert(output, returndatasize)\\n            }\\n            default {\\n                switch gt(returndatasize, 0x3f)\\n                case 0 {\\n                    // Need at least 0x40 bytes returned for properly ABI-encoded bytes values,\\n                    // revert with \\\"EVMRUN_EXECUTOR_INVALID_RETURN\\\"\\n                    // See remix: doing a `revert(\\\"EVMRUN_EXECUTOR_INVALID_RETURN\\\")` always results in\\n                    // this memory layout\\n                    mstore(output, 0x08c379a000000000000000000000000000000000000000000000000000000000)         // error identifier\\n                    mstore(add(output, 0x04), 0x0000000000000000000000000000000000000000000000000000000000000020) // starting offset\\n                    mstore(add(output, 0x24), 0x000000000000000000000000000000000000000000000000000000000000001e) // reason length\\n                    mstore(add(output, 0x44), 0x45564d52554e5f4558454355544f525f494e56414c49445f52455455524e0000) // reason\\n\\n                    revert(output, 100) // 100 = 4 + 3 * 32 (error identifier + 3 words for the ABI encoded error)\\n                }\\n                default {\\n                    // Copy result\\n                    //\\n                    // Needs to perform an ABI decode for the expected `bytes` return type of\\n                    // `executor.execScript()` as solidity will automatically ABI encode the returned bytes as:\\n                    //    [ position of the first dynamic length return value = 0x20 (32 bytes) ]\\n                    //    [ output length (32 bytes) ]\\n                    //    [ output content (N bytes) ]\\n                    //\\n                    // Perform the ABI decode by ignoring the first 32 bytes of the return data\\n                    let copysize := sub(returndatasize, 0x20)\\n                    returndatacopy(output, 0x20, copysize)\\n\\n                    mstore(0x40, add(output, copysize)) // free mem ptr set\\n                }\\n            }\\n        }\\n\\n        emit ScriptResult(address(executor), _script, _input, output);\\n\\n        return output;\\n    }\\n\\n    modifier protectState {\\n        address preKernel = address(kernel());\\n        bytes32 preAppId = appId();\\n        _; // exec\\n        require(address(kernel()) == preKernel, ERROR_PROTECTED_STATE_MODIFIED);\\n        require(appId() == preAppId, ERROR_PROTECTED_STATE_MODIFIED);\\n    }\\n}\\n\",\"keccak256\":\"0xf8b4ccf7ee558224c155604a4a0b5cc35715367cda5010fb38e21d63ec5236c9\"},\"@aragon/os/contracts/evmscript/IEVMScriptExecutor.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\n\\ninterface IEVMScriptExecutor {\\n    function execScript(bytes script, bytes input, address[] blacklist) external returns (bytes);\\n    function executorType() external pure returns (bytes32);\\n}\\n\",\"keccak256\":\"0x76ad18a278e36e14147f5b58a1157de67ce95f28813f3e1eacfedaaf53dd33b9\"},\"@aragon/os/contracts/evmscript/IEVMScriptRegistry.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./IEVMScriptExecutor.sol\\\";\\n\\n\\ncontract EVMScriptRegistryConstants {\\n    /* Hardcoded constants to save gas\\n    bytes32 internal constant EVMSCRIPT_REGISTRY_APP_ID = apmNamehash(\\\"evmreg\\\");\\n    */\\n    bytes32 internal constant EVMSCRIPT_REGISTRY_APP_ID = 0xddbcfd564f642ab5627cf68b9b7d374fb4f8a36e941a75d89c87998cef03bd61;\\n}\\n\\n\\ninterface IEVMScriptRegistry {\\n    function addScriptExecutor(IEVMScriptExecutor executor) external returns (uint id);\\n    function disableScriptExecutor(uint256 executorId) external;\\n\\n    // TODO: this should be external\\n    // See https://github.com/ethereum/solidity/issues/4832\\n    function getScriptExecutor(bytes script) public view returns (IEVMScriptExecutor);\\n}\\n\",\"keccak256\":\"0x66b255ac1537765d6e79cc0ed02df004e7bf214863773901e207baafd59dc2ce\"},\"@aragon/os/contracts/kernel/IKernel.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"../acl/IACL.sol\\\";\\nimport \\\"../common/IVaultRecoverable.sol\\\";\\n\\n\\ninterface IKernelEvents {\\n    event SetApp(bytes32 indexed namespace, bytes32 indexed appId, address app);\\n}\\n\\n\\n// This should be an interface, but interfaces can't inherit yet :(\\ncontract IKernel is IKernelEvents, IVaultRecoverable {\\n    function acl() public view returns (IACL);\\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\\n\\n    function setApp(bytes32 namespace, bytes32 appId, address app) public;\\n    function getApp(bytes32 namespace, bytes32 appId) public view returns (address);\\n}\\n\",\"keccak256\":\"0x96e9fd607b156a96905ec0108bb4fbcc5ad85212bb98e03600069bb5727d2daa\"},\"@aragon/os/contracts/kernel/KernelConstants.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\n\\ncontract KernelAppIds {\\n    /* Hardcoded constants to save gas\\n    bytes32 internal constant KERNEL_CORE_APP_ID = apmNamehash(\\\"kernel\\\");\\n    bytes32 internal constant KERNEL_DEFAULT_ACL_APP_ID = apmNamehash(\\\"acl\\\");\\n    bytes32 internal constant KERNEL_DEFAULT_VAULT_APP_ID = apmNamehash(\\\"vault\\\");\\n    */\\n    bytes32 internal constant KERNEL_CORE_APP_ID = 0x3b4bf6bf3ad5000ecf0f989d5befde585c6860fea3e574a4fab4c49d1c177d9c;\\n    bytes32 internal constant KERNEL_DEFAULT_ACL_APP_ID = 0xe3262375f45a6e2026b7e7b18c2b807434f2508fe1a2a3dfb493c7df8f4aad6a;\\n    bytes32 internal constant KERNEL_DEFAULT_VAULT_APP_ID = 0x7e852e0fcfce6551c13800f1e7476f982525c2b5277ba14b24339c68416336d1;\\n}\\n\\n\\ncontract KernelNamespaceConstants {\\n    /* Hardcoded constants to save gas\\n    bytes32 internal constant KERNEL_CORE_NAMESPACE = keccak256(\\\"core\\\");\\n    bytes32 internal constant KERNEL_APP_BASES_NAMESPACE = keccak256(\\\"base\\\");\\n    bytes32 internal constant KERNEL_APP_ADDR_NAMESPACE = keccak256(\\\"app\\\");\\n    */\\n    bytes32 internal constant KERNEL_CORE_NAMESPACE = 0xc681a85306374a5ab27f0bbc385296a54bcd314a1948b6cf61c4ea1bc44bb9f8;\\n    bytes32 internal constant KERNEL_APP_BASES_NAMESPACE = 0xf1f3eb40f5bc1ad1344716ced8b8a0431d840b5783aea1fd01786bc26f35ac0f;\\n    bytes32 internal constant KERNEL_APP_ADDR_NAMESPACE = 0xd6f028ca0e8edb4a8c9757ca4fdccab25fa1e0317da1188108f7d2dee14902fb;\\n}\\n\",\"keccak256\":\"0x817f66cfc7bfafd19a4e6b1344850c5f7b72e39a1073fe862efebe608a07c0d3\"},\"@aragon/os/contracts/lib/math/SafeMath.sol\":{\"content\":\"// See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/d51e38758e1d985661534534d5c61e27bece5042/contracts/math/SafeMath.sol\\n// Adapted to use pragma ^0.4.24 and satisfy our linter rules\\n\\npragma solidity ^0.4.24;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n    string private constant ERROR_ADD_OVERFLOW = \\\"MATH_ADD_OVERFLOW\\\";\\n    string private constant ERROR_SUB_UNDERFLOW = \\\"MATH_SUB_UNDERFLOW\\\";\\n    string private constant ERROR_MUL_OVERFLOW = \\\"MATH_MUL_OVERFLOW\\\";\\n    string private constant ERROR_DIV_ZERO = \\\"MATH_DIV_ZERO\\\";\\n\\n    /**\\n    * @dev Multiplies two numbers, reverts on overflow.\\n    */\\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (_a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = _a * _b;\\n        require(c / _a == _b, ERROR_MUL_OVERFLOW);\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\\n    */\\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\\n        uint256 c = _a / _b;\\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        require(_b <= _a, ERROR_SUB_UNDERFLOW);\\n        uint256 c = _a - _b;\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Adds two numbers, reverts on overflow.\\n    */\\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        uint256 c = _a + _b;\\n        require(c >= _a, ERROR_ADD_OVERFLOW);\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\\n    * reverts when dividing by zero.\\n    */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, ERROR_DIV_ZERO);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0x2e11c8dcead82c452ef452f4dbced40e20ae105fa4145d920dac6e077b31d846\"},\"@aragon/os/contracts/lib/math/SafeMath64.sol\":{\"content\":\"// See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/d51e38758e1d985661534534d5c61e27bece5042/contracts/math/SafeMath.sol\\n// Adapted for uint64, pragma ^0.4.24, and satisfying our linter rules\\n// Also optimized the mul() implementation, see https://github.com/aragon/aragonOS/pull/417\\n\\npragma solidity ^0.4.24;\\n\\n\\n/**\\n * @title SafeMath64\\n * @dev Math operations for uint64 with safety checks that revert on error\\n */\\nlibrary SafeMath64 {\\n    string private constant ERROR_ADD_OVERFLOW = \\\"MATH64_ADD_OVERFLOW\\\";\\n    string private constant ERROR_SUB_UNDERFLOW = \\\"MATH64_SUB_UNDERFLOW\\\";\\n    string private constant ERROR_MUL_OVERFLOW = \\\"MATH64_MUL_OVERFLOW\\\";\\n    string private constant ERROR_DIV_ZERO = \\\"MATH64_DIV_ZERO\\\";\\n\\n    /**\\n    * @dev Multiplies two numbers, reverts on overflow.\\n    */\\n    function mul(uint64 _a, uint64 _b) internal pure returns (uint64) {\\n        uint256 c = uint256(_a) * uint256(_b);\\n        require(c < 0x010000000000000000, ERROR_MUL_OVERFLOW); // 2**64 (less gas this way)\\n\\n        return uint64(c);\\n    }\\n\\n    /**\\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\\n    */\\n    function div(uint64 _a, uint64 _b) internal pure returns (uint64) {\\n        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\\n        uint64 c = _a / _b;\\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function sub(uint64 _a, uint64 _b) internal pure returns (uint64) {\\n        require(_b <= _a, ERROR_SUB_UNDERFLOW);\\n        uint64 c = _a - _b;\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Adds two numbers, reverts on overflow.\\n    */\\n    function add(uint64 _a, uint64 _b) internal pure returns (uint64) {\\n        uint64 c = _a + _b;\\n        require(c >= _a, ERROR_ADD_OVERFLOW);\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\\n    * reverts when dividing by zero.\\n    */\\n    function mod(uint64 a, uint64 b) internal pure returns (uint64) {\\n        require(b != 0, ERROR_DIV_ZERO);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0x34f18573e7b2180645c67faaff60ebc713ab22c697606d3b3ce4fe0e745955f4\"},\"@aragon/os/contracts/lib/standards/ERC165.sol\":{\"content\":\"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\n\\ncontract ERC165 {\\n    // Includes supportsInterface method:\\n    bytes4 internal constant ERC165_INTERFACE_ID = bytes4(0x01ffc9a7);\\n\\n    /**\\n    * @dev Query if a contract implements a certain interface\\n    * @param _interfaceId The interface identifier being queried, as specified in ERC-165\\n    * @return True if the contract implements the requested interface and if its not 0xffffffff, false otherwise\\n    */\\n    function supportsInterface(bytes4 _interfaceId) public pure returns (bool) {\\n        return _interfaceId == ERC165_INTERFACE_ID;\\n    }\\n}\\n\",\"keccak256\":\"0x6f67f6ece954fde87dd5e1696b4b759d18280d3e45ee54233744dee11ce1d4b5\"},\"@aragon/os/contracts/lib/token/ERC20.sol\":{\"content\":\"// See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/a9f910d34f0ab33a1ae5e714f69f9596a02b4d91/contracts/token/ERC20/ERC20.sol\\n\\npragma solidity ^0.4.24;\\n\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ncontract ERC20 {\\n    function totalSupply() public view returns (uint256);\\n\\n    function balanceOf(address _who) public view returns (uint256);\\n\\n    function allowance(address _owner, address _spender)\\n        public view returns (uint256);\\n\\n    function transfer(address _to, uint256 _value) public returns (bool);\\n\\n    function approve(address _spender, uint256 _value)\\n        public returns (bool);\\n\\n    function transferFrom(address _from, address _to, uint256 _value)\\n        public returns (bool);\\n\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 value\\n    );\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\",\"keccak256\":\"0xa2e319fde92f9e70912f09bf6e99bbf8b9b798961d54ffcba59d347d37bde1b7\"},\"@aragon/staking/interfaces/0.4/ILockManager.sol\":{\"content\":\"pragma solidity >=0.4 <0.5;\\n\\n\\ninterface ILockManager {\\n    /**\\n     * @notice Check if `_user`'s lock by `_lockManager` can be unlocked\\n     * @param _user Owner of lock\\n     * @param _amount Amount of locked tokens to unlock\\n     * @return Whether given user's lock can be unlocked\\n     */\\n    function canUnlock(address _user, uint256 _amount) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x60c38edbd06f85c1aef0a199487f4a05ccc69a36d733a890abb48024b39b9e43\"},\"@aragon/staking/interfaces/0.4/IStaking.sol\":{\"content\":\"pragma solidity >=0.4 <0.5;\\n\\n\\ninterface IStaking {\\n    // IERC-900\\n    function stake(uint256 _amount, bytes _data) external;\\n    function stakeFor(address _user, uint256 _amount, bytes _data) external;\\n    function unstake(uint256 _amount, bytes _data) external;\\n\\n    function totalStakedFor(address _addr) external view returns (uint256);\\n    function totalStaked() external view returns (uint256);\\n    function token() external view returns (address);\\n    function supportsHistory() external pure returns (bool);\\n\\n    function lastStakedFor(address addr) external view returns (uint256);\\n    function totalStakedForAt(address addr, uint256 blockNumber) external view returns (uint256);\\n    function totalStakedAt(uint256 blockNumber) external view returns (uint256);\\n\\n    // ILockable\\n    function allowManager(address _lockManager, uint256 _allowance, bytes _data) external;\\n    function unlockAndRemoveManager(address _user, address _lockManager) external;\\n    function increaseLockAllowance(address _lockManager, uint256 _allowance) external;\\n    function decreaseLockAllowance(address _user, address _lockManager, uint256 _allowance) external;\\n    function lock(address _user, uint256 _amount) external;\\n    function unlock(address _user, address _lockManager, uint256 _amount) external;\\n    function slash(address _user, address _to, uint256 _amount) external;\\n    function slashAndUnstake(address _user, address _to, uint256 _amount) external;\\n\\n    function getLock(address _user, address _lockManager) external view returns (uint256 _amount, uint256 _allowance);\\n    function unlockedBalanceOf(address _user) external view returns (uint256);\\n    function lockedBalanceOf(address _user) external view returns (uint256);\\n    function getBalancesOf(address _user) external view returns (uint256 staked, uint256 locked);\\n    function canUnlock(address _sender, address _user, address _lockManager, uint256 _amount) external view returns (bool);\\n\\n    // Misc.\\n    function transfer(address _to, uint256 _amount) external;\\n    function transferAndUnstake(address _to, uint256 _amount) external;\\n}\\n\",\"keccak256\":\"0xc5452f8851176a7fe80b8182639abe40912d9f7634d00896c2049cca208a9937\"},\"@aragon/staking/interfaces/0.4/IStakingFactory.sol\":{\"content\":\"pragma solidity >=0.4 <0.5;\\n\\nimport \\\"./IStaking.sol\\\";\\n\\n\\ninterface IStakingFactory {\\n    function getOrCreateInstance(/* ERC20 */ address token) external returns (IStaking);\\n\\n    function existsInstance(/* ERC20 */ address token) external view returns (bool);\\n    function getInstance(/* ERC20 */ address token) external view returns (IStaking);\\n}\\n\",\"keccak256\":\"0xd796f7f8808d9a04bda0069d6611abf71609d87e256a8c4908eb8b805c7a4be3\"},\"contracts/Agreement.sol\":{\"content\":\"/*\\n * SPDX-License-Identitifer:    GPL-3.0-or-later\\n */\\n\\npragma solidity 0.4.24;\\n\\nimport \\\"@aragon/os/contracts/acl/IACLOracle.sol\\\";\\nimport \\\"@aragon/os/contracts/apps/AragonApp.sol\\\";\\nimport \\\"@aragon/os/contracts/apps/disputable/IAgreement.sol\\\";\\nimport \\\"@aragon/os/contracts/apps/disputable/DisputableAragonApp.sol\\\";\\nimport \\\"@aragon/os/contracts/common/ConversionHelpers.sol\\\";\\nimport \\\"@aragon/os/contracts/common/SafeERC20.sol\\\";\\nimport \\\"@aragon/os/contracts/lib/math/SafeMath.sol\\\";\\nimport \\\"@aragon/os/contracts/lib/math/SafeMath64.sol\\\";\\nimport \\\"@aragon/os/contracts/lib/token/ERC20.sol\\\";\\n\\nimport \\\"@aragon/staking/interfaces/0.4/IStaking.sol\\\";\\nimport \\\"@aragon/staking/interfaces/0.4/IStakingFactory.sol\\\";\\nimport \\\"@aragon/staking/interfaces/0.4/ILockManager.sol\\\";\\n\\nimport \\\"./arbitration/IArbitrable.sol\\\";\\nimport \\\"./arbitration/IAragonAppFeesCashier.sol\\\";\\n\\n\\ncontract Agreement is IArbitrable, ILockManager, IAgreement, IACLOracle, AragonApp {\\n    using SafeMath for uint256;\\n    using SafeMath64 for uint64;\\n    using SafeERC20 for ERC20;\\n\\n    /* Arbitrator outcomes constants */\\n    uint256 internal constant DISPUTES_POSSIBLE_OUTCOMES = 2;\\n    // Note that Aragon Court treats the possible outcomes as arbitrary numbers, leaving the Arbitrable (us) to define how to understand them.\\n    // Some outcomes [0, 1, and 2] are reserved by Aragon Court: \\\"missing\\\", \\\"leaked\\\", and \\\"refused\\\", respectively.\\n    // This Arbitrable introduces the concept of the challenger/submitter (a binary outcome) as 3/4.\\n    // Note that Aragon Court emits the lowest outcome in the event of a tie, and so for us, we prefer the challenger.\\n    uint256 internal constant DISPUTES_RULING_CHALLENGER = 3;\\n    uint256 internal constant DISPUTES_RULING_SUBMITTER = 4;\\n\\n    /* Validation errors */\\n    string internal constant ERROR_SENDER_NOT_ALLOWED = \\\"AGR_SENDER_NOT_ALLOWED\\\";\\n    string internal constant ERROR_SIGNER_MUST_SIGN = \\\"AGR_SIGNER_MUST_SIGN\\\";\\n    string internal constant ERROR_SIGNER_ALREADY_SIGNED = \\\"AGR_SIGNER_ALREADY_SIGNED\\\";\\n    string internal constant ERROR_INVALID_SIGNING_SETTING = \\\"AGR_INVALID_SIGNING_SETTING\\\";\\n    string internal constant ERROR_INVALID_SETTLEMENT_OFFER = \\\"AGR_INVALID_SETTLEMENT_OFFER\\\";\\n    string internal constant ERROR_ACTION_DOES_NOT_EXIST = \\\"AGR_ACTION_DOES_NOT_EXIST\\\";\\n    string internal constant ERROR_CHALLENGE_DOES_NOT_EXIST = \\\"AGR_CHALLENGE_DOES_NOT_EXIST\\\";\\n    string internal constant ERROR_TOKEN_DEPOSIT_FAILED = \\\"AGR_TOKEN_DEPOSIT_FAILED\\\";\\n    string internal constant ERROR_TOKEN_TRANSFER_FAILED = \\\"AGR_TOKEN_TRANSFER_FAILED\\\";\\n    string internal constant ERROR_TOKEN_APPROVAL_FAILED = \\\"AGR_TOKEN_APPROVAL_FAILED\\\";\\n    string internal constant ERROR_TOKEN_NOT_CONTRACT = \\\"AGR_TOKEN_NOT_CONTRACT\\\";\\n    string internal constant ERROR_SETTING_DOES_NOT_EXIST = \\\"AGR_SETTING_DOES_NOT_EXIST\\\";\\n    string internal constant ERROR_ARBITRATOR_NOT_CONTRACT = \\\"AGR_ARBITRATOR_NOT_CONTRACT\\\";\\n    string internal constant ERROR_STAKING_FACTORY_NOT_CONTRACT = \\\"AGR_STAKING_FACTORY_NOT_CONTRACT\\\";\\n    string internal constant ERROR_ACL_ORACLE_SIGNER_MISSING = \\\"AGR_ACL_ORACLE_SIGNER_MISSING\\\";\\n    string internal constant ERROR_ACL_ORACLE_SIGNER_NOT_ADDRESS = \\\"AGR_ACL_ORACLE_SIGNER_NOT_ADDR\\\";\\n\\n    /* Disputable related errors */\\n    string internal constant ERROR_SENDER_CANNOT_CHALLENGE_ACTION = \\\"AGR_SENDER_CANT_CHALLENGE_ACTION\\\";\\n    string internal constant ERROR_DISPUTABLE_NOT_CONTRACT = \\\"AGR_DISPUTABLE_NOT_CONTRACT\\\";\\n    string internal constant ERROR_DISPUTABLE_NOT_ACTIVE = \\\"AGR_DISPUTABLE_NOT_ACTIVE\\\";\\n    string internal constant ERROR_DISPUTABLE_ALREADY_ACTIVE = \\\"AGR_DISPUTABLE_ALREADY_ACTIVE\\\";\\n    string internal constant ERROR_COLLATERAL_REQUIREMENT_DOES_NOT_EXIST = \\\"AGR_COL_REQ_DOES_NOT_EXIST\\\";\\n\\n    /* Action related errors */\\n    string internal constant ERROR_CANNOT_CHALLENGE_ACTION = \\\"AGR_CANNOT_CHALLENGE_ACTION\\\";\\n    string internal constant ERROR_CANNOT_CLOSE_ACTION = \\\"AGR_CANNOT_CLOSE_ACTION\\\";\\n    string internal constant ERROR_CANNOT_SETTLE_ACTION = \\\"AGR_CANNOT_SETTLE_ACTION\\\";\\n    string internal constant ERROR_CANNOT_DISPUTE_ACTION = \\\"AGR_CANNOT_DISPUTE_ACTION\\\";\\n    string internal constant ERROR_CANNOT_RULE_ACTION = \\\"AGR_CANNOT_RULE_ACTION\\\";\\n    string internal constant ERROR_CANNOT_SUBMIT_EVIDENCE = \\\"AGR_CANNOT_SUBMIT_EVIDENCE\\\";\\n    string internal constant ERROR_CANNOT_CLOSE_EVIDENCE_PERIOD = \\\"AGR_CANNOT_CLOSE_EVIDENCE_PERIOD\\\";\\n\\n    // This role will be checked against the Disputable app when users try to challenge actions.\\n    // It is expected to be configured per Disputable app. For reference, see `canPerformChallenge()`.\\n    // bytes32 public constant CHALLENGE_ROLE = keccak256(\\\"CHALLENGE_ROLE\\\");\\n    bytes32 public constant CHALLENGE_ROLE = 0xef025787d7cd1a96d9014b8dc7b44899b8c1350859fb9e1e05f5a546dd65158d;\\n\\n    // bytes32 public constant CHANGE_AGREEMENT_ROLE = keccak256(\\\"CHANGE_AGREEMENT_ROLE\\\");\\n    bytes32 public constant CHANGE_AGREEMENT_ROLE = 0x07813bca4905795fa22783885acd0167950db28f2d7a40b70f666f429e19f1d9;\\n\\n    // bytes32 public constant MANAGE_DISPUTABLE_ROLE = keccak256(\\\"MANAGE_DISPUTABLE_ROLE\\\");\\n    bytes32 public constant MANAGE_DISPUTABLE_ROLE = 0x2309a8cbbd5c3f18649f3b7ac47a0e7b99756c2ac146dda1ffc80d3f80827be6;\\n\\n    event Signed(address indexed signer, uint256 settingId);\\n    event SettingChanged(uint256 settingId);\\n    event AppFeesCashierSynced(IAragonAppFeesCashier newAppFeesCashier);\\n    event DisputableAppActivated(address indexed disputable);\\n    event DisputableAppDeactivated(address indexed disputable);\\n    event CollateralRequirementChanged(address indexed disputable, uint256 collateralRequirementId);\\n\\n    struct Setting {\\n        IArbitrator arbitrator;\\n        IAragonAppFeesCashier aragonAppFeesCashier; // Fees cashier to deposit action fees (linked to the selected arbitrator)\\n        string title;\\n        bytes content;\\n    }\\n\\n    struct CollateralRequirement {\\n        ERC20 token;                        // ERC20 token to be used for collateral\\n        uint64 challengeDuration;           // Challenge duration, during which the submitter can raise a dispute\\n        uint256 actionAmount;               // Amount of collateral token to be locked from the submitter's staking pool when creating actions\\n        uint256 challengeAmount;            // Amount of collateral token to be locked from the challenger's own balance when challenging actions\\n        IStaking staking;                   // Staking pool cache for the collateral token -- will never change\\n    }\\n\\n    struct DisputableInfo {\\n        bool activated;                                                     // Whether the Disputable app is active\\n        uint256 nextCollateralRequirementsId;                               // Identification number of the next collateral requirement\\n        mapping (uint256 => CollateralRequirement) collateralRequirements;  // List of collateral requirements indexed by ID\\n    }\\n\\n    struct Action {\\n        DisputableAragonApp disputable;     // Disputable app that created the action\\n        uint256 disputableActionId;         // Identification number of the action on the Disputable app\\n        uint256 collateralRequirementId;    // Identification number of the collateral requirement applicable to the action\\n        uint256 settingId;                  // Identification number of the agreement setting applicable to the action\\n        address submitter;                  // Address that submitted the action\\n        bool closed;                        // Whether the action is closed (and cannot be challenged anymore)\\n        bytes context;                      // Link to a human-readable context for the given action\\n        uint256 lastChallengeId;            // Identification number of the action's most recent challenge, if any\\n    }\\n\\n    struct ArbitratorFees {\\n        ERC20 token;                        // ERC20 token used for the arbitration fees\\n        uint256 amount;                     // Amount of arbitration fees\\n    }\\n\\n    struct Challenge {\\n        uint256 actionId;                        // Identification number of the action associated to the challenge\\n        address challenger;                      // Address that challenged the action\\n        uint64 endDate;                          // Last date the submitter can raise a dispute against the challenge\\n        bytes context;                           // Link to a human-readable context for the challenge\\n        uint256 settlementOffer;                 // Amount of collateral tokens the challenger would accept without involving the arbitrator\\n        ArbitratorFees challengerArbitratorFees; // Arbitration fees paid by the challenger (in advance)\\n        ArbitratorFees submitterArbitratorFees;  // Arbitration fees paid by the submitter (on dispute creation)\\n        ChallengeState state;                    // Current state of the challenge\\n        bool submitterFinishedEvidence;          // Whether the action submitter has finished submitting evidence for the raised dispute\\n        bool challengerFinishedEvidence;         // Whether the action challenger has finished submitting evidence for the raised dispute\\n        uint256 disputeId;                       // Identification number of the dispute on the arbitrator\\n        uint256 ruling;                          // Ruling given from the arbitrator for the dispute\\n    }\\n\\n    IStakingFactory public stakingFactory;                           // Staking factory, for finding each collateral token's staking pool\\n\\n    uint256 private nextSettingId;\\n    mapping (uint256 => Setting) private settings;                  // List of historic agreement settings indexed by ID (starting at 1)\\n    mapping (address => uint256) private lastSettingSignedBy;       // Mapping of address => last agreement setting signed\\n    mapping (address => DisputableInfo) private disputableInfos;    // Mapping of Disputable app => disputable infos\\n\\n    uint256 private nextActionId;\\n    mapping (uint256 => Action) private actions;                    // List of actions indexed by ID (starting at 1)\\n\\n    uint256 private nextChallengeId;\\n    mapping (uint256 => Challenge) private challenges;              // List of challenges indexed by ID (starting at 1)\\n    mapping (uint256 => uint256) private challengeByDispute;        // Mapping of arbitrator's dispute ID => challenge ID\\n\\n    /**\\n    * @notice Initialize Agreement for \\\"`_title`\\\" and content \\\"`_content`\\\", with arbitrator `_arbitrator` and staking factory `_factory`\\n    * @param _arbitrator Address of the IArbitrator that will be used to resolve disputes\\n    * @param _setAppFeesCashier Whether to integrate with the IArbitrator's fee cashier\\n    * @param _title String indicating a short description\\n    * @param _content Link to a human-readable text that describes the initial rules for the Agreement\\n    * @param _stakingFactory Staking factory for finding each collateral token's staking pool\\n    */\\n    function initialize(\\n        IArbitrator _arbitrator,\\n        bool _setAppFeesCashier,\\n        string _title,\\n        bytes _content,\\n        IStakingFactory _stakingFactory\\n    )\\n        external\\n    {\\n        initialized();\\n        require(isContract(address(_stakingFactory)), ERROR_STAKING_FACTORY_NOT_CONTRACT);\\n\\n        stakingFactory = _stakingFactory;\\n\\n        nextSettingId = 1;   // Agreement setting ID zero is considered the null agreement setting for further validations\\n        nextActionId = 1;    // Action ID zero is considered the null action for further validations\\n        nextChallengeId = 1; // Challenge ID zero is considered the null challenge for further validations\\n        _newSetting(_arbitrator, _setAppFeesCashier, _title, _content);\\n    }\\n\\n    /**\\n    * @notice Update Agreement to title \\\"`_title`\\\" and content \\\"`_content`\\\", with arbitrator `_arbitrator`\\n    * @dev Initialization check is implicitly provided by the `auth()` modifier\\n    * @param _arbitrator Address of the IArbitrator that will be used to resolve disputes\\n    * @param _setAppFeesCashier Whether to integrate with the IArbitrator's fee cashier\\n    * @param _title String indicating a short description\\n    * @param _content Link to a human-readable text that describes the new rules for the Agreement\\n    */\\n    function changeSetting(\\n        IArbitrator _arbitrator,\\n        bool _setAppFeesCashier,\\n        string _title,\\n        bytes _content\\n    )\\n        external\\n        auth(CHANGE_AGREEMENT_ROLE)\\n    {\\n        _newSetting(_arbitrator, _setAppFeesCashier, _title, _content);\\n    }\\n\\n    /**\\n    * @notice Sync app fees cashier address\\n    * @dev The app fees cashier address is being cached in the contract to save gas.\\n    *      This can be called permission-lessly to allow any account to re-sync the cashier when changed by the arbitrator.\\n    *      Initialization check is implicitly provided by `_getSetting()`, as valid settings can only be created after initialization.\\n    */\\n    function syncAppFeesCashier() external {\\n        Setting storage setting = _getSetting(_getCurrentSettingId());\\n        IAragonAppFeesCashier newAppFeesCashier = _getArbitratorFeesCashier(setting.arbitrator);\\n        IAragonAppFeesCashier currentAppFeesCashier = setting.aragonAppFeesCashier;\\n\\n        // Sync the app fees cashier only if there was one set before and it's different from the arbitrator's current one\\n        if (currentAppFeesCashier != IAragonAppFeesCashier(0) && currentAppFeesCashier != newAppFeesCashier) {\\n            setting.aragonAppFeesCashier = newAppFeesCashier;\\n            emit AppFeesCashierSynced(newAppFeesCashier);\\n        }\\n    }\\n\\n    /**\\n    * @notice Activate Disputable app `_disputableAddress`\\n    * @dev Initialization check is implicitly provided by the `auth()` modifier\\n    * @param _disputableAddress Address of the Disputable app\\n    * @param _collateralToken Address of the ERC20 token to be used for collateral\\n    * @param _actionAmount Amount of collateral tokens that will be locked every time an action is submitted\\n    * @param _challengeAmount Amount of collateral tokens that will be locked every time an action is challenged\\n    * @param _challengeDuration Challenge duration, during which the submitter can raise a dispute\\n    */\\n    function activate(\\n        address _disputableAddress,\\n        ERC20 _collateralToken,\\n        uint64 _challengeDuration,\\n        uint256 _actionAmount,\\n        uint256 _challengeAmount\\n    )\\n        external\\n        auth(MANAGE_DISPUTABLE_ROLE)\\n    {\\n        require(isContract(_disputableAddress), ERROR_DISPUTABLE_NOT_CONTRACT);\\n\\n        DisputableInfo storage disputableInfo = disputableInfos[_disputableAddress];\\n        _ensureInactiveDisputable(disputableInfo);\\n\\n        DisputableAragonApp disputable = DisputableAragonApp(_disputableAddress);\\n        disputableInfo.activated = true;\\n\\n        // If the disputable app is being activated for the first time, then we need to set-up its initial collateral\\n        // requirement and set its Agreement reference to here.\\n        if (disputable.getAgreement() != IAgreement(this)) {\\n            disputable.setAgreement(IAgreement(this));\\n            uint256 nextId = disputableInfo.nextCollateralRequirementsId;\\n            disputableInfo.nextCollateralRequirementsId = nextId > 0 ? nextId : 1;\\n        }\\n        _changeCollateralRequirement(disputable, disputableInfo, _collateralToken, _challengeDuration, _actionAmount, _challengeAmount);\\n\\n        emit DisputableAppActivated(disputable);\\n    }\\n\\n    /**\\n    * @notice Deactivate Disputable app `_disputable`\\n    * @dev Initialization check is implicitly provided by the `auth()` modifier\\n    * @param _disputableAddress Address of the Disputable app to be deactivated\\n    */\\n    function deactivate(address _disputableAddress) external auth(MANAGE_DISPUTABLE_ROLE) {\\n        DisputableInfo storage disputableInfo = disputableInfos[_disputableAddress];\\n        _ensureActiveDisputable(disputableInfo);\\n\\n        disputableInfo.activated = false;\\n        emit DisputableAppDeactivated(_disputableAddress);\\n    }\\n\\n    /**\\n    * @notice Change `_disputable`'s collateral requirements\\n    * @dev Initialization check is implicitly provided by the `auth()` modifier\\n    * @param _disputable Address of the Disputable app\\n    * @param _collateralToken Address of the ERC20 token to be used for collateral\\n    * @param _actionAmount Amount of collateral tokens that will be locked every time an action is submitted\\n    * @param _challengeAmount Amount of collateral tokens that will be locked every time an action is challenged\\n    * @param _challengeDuration Challenge duration, during which the submitter can raise a dispute\\n    */\\n    function changeCollateralRequirement(\\n        DisputableAragonApp _disputable,\\n        ERC20 _collateralToken,\\n        uint64 _challengeDuration,\\n        uint256 _actionAmount,\\n        uint256 _challengeAmount\\n    )\\n        external\\n        auth(MANAGE_DISPUTABLE_ROLE)\\n    {\\n        DisputableInfo storage disputableInfo = disputableInfos[address(_disputable)];\\n        _ensureActiveDisputable(disputableInfo);\\n\\n        _changeCollateralRequirement(_disputable, disputableInfo, _collateralToken, _challengeDuration, _actionAmount, _challengeAmount);\\n    }\\n\\n    /**\\n    * @notice Sign the agreement up-to setting #`_settingId`\\n    * @dev Callable by any account; only accounts that have signed the latest version of the agreement can submit new disputable actions.\\n    *      Initialization check is implicitly provided by `_settingId < nextSettingId`, as valid settings can only be created after initialization.\\n    * @param _settingId Last setting ID the user is agreeing with\\n    */\\n    function sign(uint256 _settingId) external {\\n        uint256 lastSettingIdSigned = lastSettingSignedBy[msg.sender];\\n        require(lastSettingIdSigned < _settingId, ERROR_SIGNER_ALREADY_SIGNED);\\n        require(_settingId < nextSettingId, ERROR_INVALID_SIGNING_SETTING);\\n\\n        lastSettingSignedBy[msg.sender] = _settingId;\\n        emit Signed(msg.sender, _settingId);\\n    }\\n\\n    /**\\n    * @notice Register action #`_disputableActionId` from disputable `msg.sender` for submitter `_submitter` with context `_context`\\n    * @dev This function should be called from the Disputable app each time a new disputable action is created.\\n    *      Each disputable action ID must only be registered once; this is how the Agreement gets notified about each disputable action.\\n    *      Initialization check is implicitly provided by `_ensureActiveDisputable()` as Disputable apps can only be activated\\n    *      via `activate()` which already requires initialization.\\n    *      IMPORTANT: Note the responsibility of the Disputable app in terms of providing the correct `_submitter` parameter.\\n    *      Users are required to trust that all Disputable apps activated with this Agreement have implemented this correctly, as\\n    *      otherwise funds could be maliciously locked from the incorrect account on new actions.\\n    * @param _disputableActionId Identification number of the action on the Disputable app\\n    * @param _context Link to a human-readable context for the given action\\n    * @param _submitter Address that submitted the action\\n    * @return Unique identification number for the created action on the Agreement\\n    */\\n    function newAction(uint256 _disputableActionId, bytes _context, address _submitter) external returns (uint256) {\\n        DisputableInfo storage disputableInfo = disputableInfos[msg.sender];\\n        _ensureActiveDisputable(disputableInfo);\\n\\n        uint256 currentSettingId = _getCurrentSettingId();\\n        uint256 lastSettingIdSigned = lastSettingSignedBy[_submitter];\\n        require(lastSettingIdSigned == currentSettingId, ERROR_SIGNER_MUST_SIGN);\\n\\n        // An initial collateral requirement is created when disputable apps are activated, thus length is always greater than 0\\n        uint256 currentCollateralRequirementId = disputableInfo.nextCollateralRequirementsId - 1;\\n        CollateralRequirement storage requirement = _getCollateralRequirement(disputableInfo, currentCollateralRequirementId);\\n        _lockBalance(requirement.staking, _submitter, requirement.actionAmount);\\n\\n        // Create new action\\n        uint256 id = nextActionId++;\\n        Action storage action = actions[id];\\n\\n        // Pay action submission fees\\n        Setting storage setting = _getSetting(currentSettingId);\\n        DisputableAragonApp disputable = DisputableAragonApp(msg.sender);\\n        _payAppFees(setting, disputable, _submitter, id);\\n\\n        action.disputable = disputable;\\n        action.disputableActionId = _disputableActionId;\\n        action.collateralRequirementId = currentCollateralRequirementId;\\n        action.settingId = currentSettingId;\\n        action.submitter = _submitter;\\n        action.context = _context;\\n\\n        emit ActionSubmitted(id, msg.sender);\\n        return id;\\n    }\\n\\n    /**\\n    * @notice Close action #`_actionId`\\n    * @dev This function closes actions that:\\n    *      - Are not currently challenged nor disputed, or\\n    *      - Were previously disputed but ruled in favour of the submitter or voided\\n    *      Disputable apps may call this method directly at the end of an action, but is also accessible in a permission-less manner\\n    *      in case the app does not close its own actions automatically (e.g. disputable votes that don't pass).\\n    *      Can be called multiple times; it does nothing if the action is already closed.\\n    *      Initialization check is implicitly provided by `_getAction()` as disputable actions can only be created via `newAction()`.\\n    * @param _actionId Identification number of the action to be closed\\n    */\\n    function closeAction(uint256 _actionId) external {\\n        Action storage action = _getAction(_actionId);\\n        if (action.closed) {\\n            return;\\n        }\\n\\n        require(_canClose(action), ERROR_CANNOT_CLOSE_ACTION);\\n        (, CollateralRequirement storage requirement) = _getDisputableInfoFor(action);\\n        _unlockBalance(requirement.staking, action.submitter, requirement.actionAmount);\\n        _unsafeCloseAction(_actionId, action);\\n    }\\n\\n    /**\\n    * @notice Challenge action #`_actionId`\\n    * @dev This is only callable by those who hold the CHALLENGE_ROLE on the related Disputable app.\\n    *      Can be called multiple times per action, until a challenge is successful (settled or ruled for challenger).\\n    *      Initialization check is implicitly provided by `_getAction()` as disputable actions can only be created via `newAction()`.\\n    * @param _actionId Identification number of the action to be challenged\\n    * @param _settlementOffer Amount of collateral tokens the challenger would accept for resolving the dispute without involving the arbitrator\\n    * @param _finishedEvidence Whether the challenger is finished submitting evidence with the challenge context\\n    * @param _context Link to a human-readable context for the challenge\\n    */\\n    function challengeAction(uint256 _actionId, uint256 _settlementOffer, bool _finishedEvidence, bytes _context) external {\\n        Action storage action = _getAction(_actionId);\\n        require(_canChallenge(action), ERROR_CANNOT_CHALLENGE_ACTION);\\n\\n        (DisputableAragonApp disputable, CollateralRequirement storage requirement) = _getDisputableInfoFor(action);\\n        require(_canPerformChallenge(disputable, msg.sender), ERROR_SENDER_CANNOT_CHALLENGE_ACTION);\\n        require(_settlementOffer <= requirement.actionAmount, ERROR_INVALID_SETTLEMENT_OFFER);\\n\\n        uint256 challengeId = _createChallenge(_actionId, action, msg.sender, requirement, _settlementOffer, _finishedEvidence, _context);\\n        action.lastChallengeId = challengeId;\\n        disputable.onDisputableActionChallenged(action.disputableActionId, challengeId, msg.sender);\\n        emit ActionChallenged(_actionId, challengeId);\\n    }\\n\\n    /**\\n    * @notice Settle challenged action #`_actionId`, accepting the settlement offer\\n    * @dev This can be accessed by both the submitter (at any time) or any account (after the settlement period has passed).\\n    *      Can only be called once (if at all) per opened challenge.\\n    *      Initialization check is implicitly provided by `_getChallengedAction()` as disputable actions can only be created via `newAction()`.\\n    * @param _actionId Identification number of the action to be settled\\n    */\\n    function settleAction(uint256 _actionId) external {\\n        (Action storage action, Challenge storage challenge, uint256 challengeId) = _getChallengedAction(_actionId);\\n        address submitter = action.submitter;\\n\\n        if (msg.sender == submitter) {\\n            require(_canSettle(challenge), ERROR_CANNOT_SETTLE_ACTION);\\n        } else {\\n            require(_canClaimSettlement(challenge), ERROR_CANNOT_SETTLE_ACTION);\\n        }\\n\\n        (DisputableAragonApp disputable, CollateralRequirement storage requirement) = _getDisputableInfoFor(action);\\n        uint256 actionCollateral = requirement.actionAmount;\\n        uint256 settlementOffer = challenge.settlementOffer;\\n\\n        // The settlement offer was already checked to be up-to the collateral amount upon challenge creation\\n        // However, we cap it to collateral amount to be safe\\n        // With this, we can avoid using SafeMath to calculate `unlockedAmount`\\n        uint256 slashedAmount = settlementOffer >= actionCollateral ? actionCollateral : settlementOffer;\\n        uint256 unlockedAmount = actionCollateral - slashedAmount;\\n\\n        // Unlock and slash action collateral for settlement offer\\n        address challenger = challenge.challenger;\\n        IStaking staking = requirement.staking;\\n        _unlockBalance(staking, submitter, unlockedAmount);\\n        _slashBalance(staking, submitter, challenger, slashedAmount);\\n\\n        // Transfer challenge collateral and challenger arbitrator fees back to the challenger\\n        _transferTo(requirement.token, challenger, requirement.challengeAmount);\\n        _transferTo(challenge.challengerArbitratorFees.token, challenger, challenge.challengerArbitratorFees.amount);\\n\\n        challenge.state = ChallengeState.Settled;\\n        disputable.onDisputableActionRejected(action.disputableActionId);\\n        emit ActionSettled(_actionId, challengeId);\\n        _unsafeCloseAction(_actionId, action);\\n    }\\n\\n    /**\\n    * @notice Dispute challenged action #`_actionId`, raising it to the arbitrator\\n    * @dev Only the action submitter can create a dispute for an action with an open challenge.\\n    *      Can only be called once (if at all) per opened challenge.\\n    *      Initialization check is implicitly provided by `_getChallengedAction()` as disputable actions can only be created via `newAction()`.\\n    * @param _actionId Identification number of the action to be disputed\\n    * @param _submitterFinishedEvidence Whether the submitter was finished submitting evidence with their action context\\n    */\\n    function disputeAction(uint256 _actionId, bool _submitterFinishedEvidence) external {\\n        (Action storage action, Challenge storage challenge, uint256 challengeId) = _getChallengedAction(_actionId);\\n        require(_canDispute(challenge), ERROR_CANNOT_DISPUTE_ACTION);\\n\\n        address submitter = action.submitter;\\n        require(msg.sender == submitter, ERROR_SENDER_NOT_ALLOWED);\\n\\n        IArbitrator arbitrator = _getArbitratorFor(action);\\n        bytes memory metadata = abi.encodePacked(appId(), action.lastChallengeId);\\n        uint256 disputeId = _createDispute(action, challenge, arbitrator, metadata);\\n        bool challengerFinishedEvidence = challenge.challengerFinishedEvidence;\\n        arbitrator.submitEvidence(disputeId, submitter, action.context);\\n        arbitrator.submitEvidence(disputeId, challenge.challenger, challenge.context);\\n\\n        if (_submitterFinishedEvidence && challengerFinishedEvidence) {\\n            // Try-catch for: arbitrator.closeEvidencePeriod(disputeId);\\n            bytes memory closeEvidencePeriodCalldata = abi.encodeWithSelector(arbitrator.closeEvidencePeriod.selector, disputeId);\\n            address(arbitrator).call(closeEvidencePeriodCalldata);\\n        }\\n\\n        challenge.state = ChallengeState.Disputed;\\n        challenge.submitterFinishedEvidence = _submitterFinishedEvidence;\\n        challenge.disputeId = disputeId;\\n        challengeByDispute[disputeId] = challengeId;\\n        emit ActionDisputed(_actionId, challengeId);\\n    }\\n\\n    /**\\n    * @notice Submit evidence for dispute #`_disputeId`\\n    * @dev Only callable by the action submitter or challenger.\\n    *      Can be called as many times as desired until the dispute is over.\\n    *      Initialization check is implicitly provided by `_getDisputedAction()` as disputable actions can only be created via `newAction()`.\\n    * @param _disputeId Identification number of the dispute on the arbitrator\\n    * @param _evidence Evidence data to be submitted\\n    * @param _finished Whether the evidence submitter is now finished submitting evidence\\n    */\\n    function submitEvidence(uint256 _disputeId, bytes _evidence, bool _finished) external {\\n        (, Action storage action, , Challenge storage challenge) = _getDisputedAction(_disputeId);\\n        require(_isDisputed(challenge), ERROR_CANNOT_SUBMIT_EVIDENCE);\\n\\n        IArbitrator arbitrator = _getArbitratorFor(action);\\n        if (msg.sender == action.submitter) {\\n            // If the submitter finished submitting evidence earlier, also emit this event as finished\\n            bool submitterFinishedEvidence = challenge.submitterFinishedEvidence || _finished;\\n            arbitrator.submitEvidence(_disputeId, msg.sender, _evidence);\\n            challenge.submitterFinishedEvidence = submitterFinishedEvidence;\\n        } else if (msg.sender == challenge.challenger) {\\n            // If the challenger finished submitting evidence earlier, also emit this event as finished\\n            bool challengerFinishedEvidence = challenge.challengerFinishedEvidence || _finished;\\n            arbitrator.submitEvidence(_disputeId, msg.sender, _evidence);\\n            challenge.challengerFinishedEvidence = challengerFinishedEvidence;\\n        } else {\\n            revert(ERROR_SENDER_NOT_ALLOWED);\\n        }\\n    }\\n\\n    /**\\n    * @notice Close evidence submission period for dispute #`_disputeId`\\n    * @dev Callable by any account.\\n    *      Initialization check is implicitly provided by `_getDisputedAction()` as disputable actions can only be created via `newAction()`.\\n    * @param _disputeId Identification number of the dispute on the arbitrator\\n    */\\n    function closeEvidencePeriod(uint256 _disputeId) external {\\n        (, Action storage action, , Challenge storage challenge) = _getDisputedAction(_disputeId);\\n        require(_isDisputed(challenge), ERROR_CANNOT_SUBMIT_EVIDENCE);\\n        require(challenge.submitterFinishedEvidence && challenge.challengerFinishedEvidence, ERROR_CANNOT_CLOSE_EVIDENCE_PERIOD);\\n\\n        IArbitrator arbitrator = _getArbitratorFor(action);\\n        arbitrator.closeEvidencePeriod(_disputeId);\\n    }\\n\\n    /**\\n    * @notice Resolve the action associated to dispute #`_disputeId` with ruling `_ruling`\\n    * @dev Can only be called once per challenge by anyone once the arbitrator ruling has been finalized.\\n    *      Initialization check is implicitly provided by `_getDisputedAction()` as disputable actions can only be created via `newAction()`.\\n    * @param _disputeId Identification number of the dispute on the arbitrator\\n    */\\n    function resolve(uint256 _disputeId) external {\\n        (uint256 actionId, Action storage action, uint256 challengeId, Challenge storage challenge) = _getDisputedAction(_disputeId);\\n        require(_isDisputed(challenge), ERROR_CANNOT_RULE_ACTION);\\n\\n        IArbitrator arbitrator = _getArbitratorFor(action);\\n        (, uint256 ruling) = arbitrator.rule(_disputeId);\\n\\n        challenge.ruling = ruling;\\n        emit Ruled(arbitrator, _disputeId, ruling);\\n\\n        if (ruling == DISPUTES_RULING_SUBMITTER) {\\n            _acceptAction(actionId, action, challengeId, challenge);\\n        } else if (ruling == DISPUTES_RULING_CHALLENGER) {\\n            _rejectAction(actionId, action, challengeId, challenge);\\n        } else {\\n            _voidAction(actionId, action, challengeId, challenge);\\n        }\\n    }\\n\\n    // Getter fns\\n\\n    /**\\n    * @dev Tell the identification number of the current agreement setting\\n    * @return Identification number of the current agreement setting\\n    */\\n    function getCurrentSettingId() external view returns (uint256) {\\n        return _getCurrentSettingId();\\n    }\\n\\n    /**\\n    * @dev Tell the information related to an agreement setting\\n    * @param _settingId Identification number of the agreement setting\\n    * @return arbitrator Address of the IArbitrator that will be used to resolve disputes\\n    * @return aragonAppFeesCashier Address of the fees cashier to deposit action fees (linked to the selected arbitrator)\\n    * @return title String indicating a short description\\n    * @return content Link to a human-readable text that describes the current rules for the Agreement\\n    */\\n    function getSetting(uint256 _settingId)\\n        external\\n        view\\n        returns (IArbitrator arbitrator, IAragonAppFeesCashier aragonAppFeesCashier, string title, bytes content)\\n    {\\n        Setting storage setting = _getSetting(_settingId);\\n        arbitrator = setting.arbitrator;\\n        aragonAppFeesCashier = setting.aragonAppFeesCashier;\\n        title = setting.title;\\n        content = setting.content;\\n    }\\n\\n    /**\\n    * @dev Tell the information related to a Disputable app\\n    * @param _disputable Address of the Disputable app\\n    * @return activated Whether the Disputable app is active\\n    * @return currentCollateralRequirementId Identification number of the current collateral requirement\\n    */\\n    function getDisputableInfo(address _disputable) external view returns (bool activated, uint256 currentCollateralRequirementId) {\\n        DisputableInfo storage disputableInfo = disputableInfos[_disputable];\\n        activated = disputableInfo.activated;\\n        uint256 nextId = disputableInfo.nextCollateralRequirementsId;\\n        // Since `nextCollateralRequirementsId` is initialized to 1 when disputable apps are activated, it is safe to consider the\\n        // current collateral requirement ID of a disputable app as 0 if it has not been set yet, which means it was not activated yet.\\n        currentCollateralRequirementId = nextId == 0 ? 0 : nextId - 1;\\n    }\\n\\n    /**\\n    * @dev Tell the information related to a collateral requirement of a Disputable app\\n    * @param _disputable Address of the Disputable app\\n    * @param _collateralRequirementId Identification number of the collateral requirement\\n    * @return collateralToken Address of the ERC20 token to be used for collateral\\n    * @return actionAmount Amount of collateral tokens that will be locked every time an action is created\\n    * @return challengeAmount Amount of collateral tokens that will be locked every time an action is challenged\\n    * @return challengeDuration Challenge duration, during which the submitter can raise a dispute\\n    */\\n    function getCollateralRequirement(address _disputable, uint256 _collateralRequirementId)\\n        external\\n        view\\n        returns (\\n            ERC20 collateralToken,\\n            uint64 challengeDuration,\\n            uint256 actionAmount,\\n            uint256 challengeAmount\\n        )\\n    {\\n        DisputableInfo storage disputableInfo = disputableInfos[_disputable];\\n        CollateralRequirement storage collateral = _getCollateralRequirement(disputableInfo, _collateralRequirementId);\\n        collateralToken = collateral.token;\\n        actionAmount = collateral.actionAmount;\\n        challengeAmount = collateral.challengeAmount;\\n        challengeDuration = collateral.challengeDuration;\\n    }\\n\\n    /**\\n    * @dev Tell the information related to a signer\\n    * @param _signer Address of signer\\n    * @return lastSettingIdSigned Identification number of the last agreement setting signed by the signer\\n    * @return mustSign Whether the requested signer needs to sign the current agreement setting before submitting an action\\n    */\\n    function getSigner(address _signer) external view returns (uint256 lastSettingIdSigned, bool mustSign) {\\n        (lastSettingIdSigned, mustSign) = _getSigner(_signer);\\n    }\\n\\n    /**\\n    * @dev Tell the information related to an action\\n    * @param _actionId Identification number of the action\\n    * @return disputable Address of the Disputable app that created the action\\n    * @return disputableActionId Identification number of the action on the Disputable app\\n    * @return collateralRequirementId Identification number of the collateral requirement applicable to the action\\n    * @return settingId Identification number of the agreement setting applicable to the action\\n    * @return submitter Address that submitted the action\\n    * @return closed Whether the action is closed\\n    * @return context Link to a human-readable context for the action\\n    * @return lastChallengeId Identification number of the action's most recent challenge, if any\\n    * @return lastChallengeActive Whether the action's most recent challenge is still ongoing\\n    */\\n    function getAction(uint256 _actionId)\\n        external\\n        view\\n        returns (\\n            address disputable,\\n            uint256 disputableActionId,\\n            uint256 collateralRequirementId,\\n            uint256 settingId,\\n            address submitter,\\n            bool closed,\\n            bytes context,\\n            uint256 lastChallengeId,\\n            bool lastChallengeActive\\n        )\\n    {\\n        Action storage action = _getAction(_actionId);\\n\\n        disputable = action.disputable;\\n        disputableActionId = action.disputableActionId;\\n        collateralRequirementId = action.collateralRequirementId;\\n        settingId = action.settingId;\\n        submitter = action.submitter;\\n        closed = action.closed;\\n        context = action.context;\\n        lastChallengeId = action.lastChallengeId;\\n\\n        if (lastChallengeId > 0) {\\n            (, Challenge storage challenge, ) = _getChallengedAction(_actionId);\\n            lastChallengeActive = _isWaitingChallengeAnswer(challenge) || _isDisputed(challenge);\\n        }\\n    }\\n\\n    /**\\n    * @dev Tell the information related to an action challenge\\n    * @param _challengeId Identification number of the challenge\\n    * @return actionId Identification number of the action associated to the challenge\\n    * @return challenger Address that challenged the action\\n    * @return endDate Datetime of the last date the submitter can raise a dispute against the challenge\\n    * @return context Link to a human-readable context for the challenge\\n    * @return settlementOffer Amount of collateral tokens the challenger would accept for resolving the dispute without involving the arbitrator\\n    * @return state Current state of the challenge\\n    * @return submitterFinishedEvidence Whether the action submitter has finished submitting evidence for the associated dispute\\n    * @return challengerFinishedEvidence Whether the action challenger has finished submitting evidence for the associated dispute\\n    * @return disputeId Identification number of the associated dispute on the arbitrator\\n    * @return ruling Ruling given from the arbitrator for the dispute\\n    */\\n    function getChallenge(uint256 _challengeId)\\n        external\\n        view\\n        returns (\\n            uint256 actionId,\\n            address challenger,\\n            uint64 endDate,\\n            bytes context,\\n            uint256 settlementOffer,\\n            ChallengeState state,\\n            bool submitterFinishedEvidence,\\n            bool challengerFinishedEvidence,\\n            uint256 disputeId,\\n            uint256 ruling\\n        )\\n    {\\n        Challenge storage challenge = _getChallenge(_challengeId);\\n\\n        actionId = challenge.actionId;\\n        challenger = challenge.challenger;\\n        endDate = challenge.endDate;\\n        context = challenge.context;\\n        settlementOffer = challenge.settlementOffer;\\n        state = challenge.state;\\n        submitterFinishedEvidence = challenge.submitterFinishedEvidence;\\n        challengerFinishedEvidence = challenge.challengerFinishedEvidence;\\n        disputeId = challenge.disputeId;\\n        ruling = challenge.ruling;\\n    }\\n\\n    /**\\n    * @dev Tell the arbitration fees paid for an action challenge\\n    *      Split from `getChallenge()` due to \\u201cstack too deep issues\\u201d\\n    * @param _challengeId Identification number of the challenge\\n    * @return submitterArbitratorFeesToken ERC20 token used for the arbitration fees paid by the submitter (on dispute creation)\\n    * @return submitterArbitratorFeesAmount Amount of arbitration fees paid by the submitter (on dispute creation)\\n    * @return challengerArbitratorFeesToken ERC20 token used for the arbitration fees paid by the challenger (in advance)\\n    * @return challengerArbitratorFeesAmount Amount of arbitration fees paid by the challenger (in advance)\\n    */\\n    function getChallengeArbitratorFees(uint256 _challengeId)\\n        external\\n        view\\n        returns (\\n            ERC20 submitterArbitratorFeesToken,\\n            uint256 submitterArbitratorFeesAmount,\\n            ERC20 challengerArbitratorFeesToken,\\n            uint256 challengerArbitratorFeesAmount\\n        )\\n    {\\n        Challenge storage challenge = _getChallenge(_challengeId);\\n\\n        submitterArbitratorFeesToken = challenge.submitterArbitratorFees.token;\\n        submitterArbitratorFeesAmount = challenge.submitterArbitratorFees.amount;\\n        challengerArbitratorFeesToken = challenge.challengerArbitratorFees.token;\\n        challengerArbitratorFeesAmount = challenge.challengerArbitratorFees.amount;\\n    }\\n\\n    /**\\n    * @dev Tell whether an action can be challenged\\n    * @param _actionId Identification number of the action\\n    * @return True if the action can be challenged, false otherwise\\n    */\\n    function canChallenge(uint256 _actionId) external view returns (bool) {\\n        Action storage action = _getAction(_actionId);\\n        return _canChallenge(action);\\n    }\\n\\n    /**\\n    * @dev Tell whether an action can be manually closed.\\n    *      An action can be closed if it is allowed to:\\n    *       - Proceed in the context of this Agreement (see `_canProceed()`), and\\n    *       - Be closed in the context of the originating Disputable app\\n    * @param _actionId Identification number of the action\\n    * @return True if the action can be closed, false otherwise\\n    */\\n    function canClose(uint256 _actionId) external view returns (bool) {\\n        Action storage action = _getAction(_actionId);\\n        return _canClose(action);\\n    }\\n\\n    /**\\n    * @dev Tell whether an action can be settled\\n    * @param _actionId Identification number of the action\\n    * @return True if the action can be settled, false otherwise\\n    */\\n    function canSettle(uint256 _actionId) external view returns (bool) {\\n        (, Challenge storage challenge, ) = _getChallengedAction(_actionId);\\n        return _canSettle(challenge);\\n    }\\n\\n    /**\\n    * @dev Tell whether an action can be settled by claiming its challenge settlement\\n    * @param _actionId Identification number of the action\\n    * @return True if the action settlement can be claimed, false otherwise\\n    */\\n    function canClaimSettlement(uint256 _actionId) external view returns (bool) {\\n        (, Challenge storage challenge, ) = _getChallengedAction(_actionId);\\n        return _canClaimSettlement(challenge);\\n    }\\n\\n    /**\\n    * @dev Tell whether an action can be disputed\\n    * @param _actionId Identification number of the action\\n    * @return True if the action can be disputed, false otherwise\\n    */\\n    function canDispute(uint256 _actionId) external view returns (bool) {\\n        (, Challenge storage challenge, ) = _getChallengedAction(_actionId);\\n        return _canDispute(challenge);\\n    }\\n\\n    /**\\n    * @dev Tell whether an action's dispute can be ruled\\n    * @param _actionId Identification number of the action\\n    * @return True if the action's dispute can be ruled, false otherwise\\n    */\\n    function canRuleDispute(uint256 _actionId) external view returns (bool) {\\n        (, Challenge storage challenge, ) = _getChallengedAction(_actionId);\\n        return _isDisputed(challenge);\\n    }\\n\\n    /**\\n    * @dev Tell whether an address can challenge an action\\n    * @param _actionId Identification number of the action\\n    * @param _challenger Address of the challenger\\n    * @return True if the challenger can challenge the action, false otherwise\\n    */\\n    function canPerformChallenge(uint256 _actionId, address _challenger) external view returns (bool) {\\n        Action storage action = _getAction(_actionId);\\n        return _canPerformChallenge(action.disputable, _challenger);\\n    }\\n\\n    /**\\n    * @notice Tells whether an address has already signed the Agreement\\n    * @dev ACL oracle interface conformance\\n    * @return True if a parameterized address has signed the current version of the Agreement, false otherwise\\n    */\\n    function canPerform(address /* _grantee */, address /* _where */, bytes32 /* _what */, uint256[] _how)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        // We currently expect the address as the only permission parameter because an ACL Oracle's `grantee`\\n        // argument is not provided with the original sender if the permission is set for ANY_ENTITY.\\n        require(_how.length > 0, ERROR_ACL_ORACLE_SIGNER_MISSING);\\n        require(_how[0] < 2**160, ERROR_ACL_ORACLE_SIGNER_NOT_ADDRESS);\\n\\n        address signer = address(_how[0]);\\n        (, bool mustSign) = _getSigner(signer);\\n        return !mustSign;\\n    }\\n\\n    /**\\n    * @dev ILockManager conformance.\\n    *      The Staking contract checks this on each request to unlock an amount managed by this Agreement.\\n    *      It always returns false to disable owners from unlocking their funds arbitrarily, as we\\n    *      want to control the release of the locked amount when actions are closed or settled.\\n    * @return Whether the request to unlock tokens of a given owner should be allowed\\n    */\\n    function canUnlock(address, uint256) external view returns (bool) {\\n        return false;\\n    }\\n\\n    /**\\n    * @dev Disable built-in AragonApp token recovery escape hatch.\\n    *      This app is intended to hold users' funds and we do not want to allow them to be transferred to the default vault.\\n    * @return Always false\\n    */\\n    function allowRecoverability(address /* _token */) public view returns (bool) {\\n        return false;\\n    }\\n\\n    // Internal fns\\n\\n    /**\\n    * @dev Change agreement settings\\n    * @param _arbitrator Address of the IArbitrator that will be used to resolve disputes\\n    * @param _setAppFeesCashier Whether to integrate with the IArbitrator's fee cashier\\n    * @param _title String indicating a short description\\n    * @param _content Link to a human-readable text that describes the new rules for the Agreement\\n    */\\n    function _newSetting(IArbitrator _arbitrator, bool _setAppFeesCashier, string _title, bytes _content) internal {\\n        require(isContract(address(_arbitrator)), ERROR_ARBITRATOR_NOT_CONTRACT);\\n\\n        uint256 id = nextSettingId++;\\n        Setting storage setting = settings[id];\\n        setting.title = _title;\\n        setting.content = _content;\\n        setting.arbitrator = _arbitrator;\\n\\n        // Note that if the Agreement app didn't have an app fees cashier set at the start, then it must be explicitly set later.\\n        // Arbitrators must always have at least some sort of subscription module, and having the flexibility to turn this off\\n        // on the Agreement side can be useful.\\n        setting.aragonAppFeesCashier = _setAppFeesCashier ? _getArbitratorFeesCashier(_arbitrator) : IAragonAppFeesCashier(0);\\n        emit SettingChanged(id);\\n    }\\n\\n    /**\\n    * @dev Change the collateral requirements of an active Disputable app\\n    * @param _disputable Address of the Disputable app\\n    * @param _disputableInfo Disputable info instance for the Disputable app\\n    * @param _collateralToken Address of the ERC20 token to be used for collateral\\n    * @param _actionAmount Amount of collateral tokens that will be locked every time an action is submitted\\n    * @param _challengeAmount Amount of collateral tokens that will be locked every time an action is challenged\\n    * @param _challengeDuration Challenge duration, during which the submitter can raise a dispute\\n    */\\n    function _changeCollateralRequirement(\\n        DisputableAragonApp _disputable,\\n        DisputableInfo storage _disputableInfo,\\n        ERC20 _collateralToken,\\n        uint64 _challengeDuration,\\n        uint256 _actionAmount,\\n        uint256 _challengeAmount\\n    )\\n        internal\\n    {\\n        require(isContract(address(_collateralToken)), ERROR_TOKEN_NOT_CONTRACT);\\n\\n        IStaking staking = stakingFactory.getOrCreateInstance(_collateralToken);\\n        uint256 id = _disputableInfo.nextCollateralRequirementsId++;\\n        CollateralRequirement storage collateralRequirement = _disputableInfo.collateralRequirements[id];\\n        collateralRequirement.token = _collateralToken;\\n        collateralRequirement.challengeDuration = _challengeDuration;\\n        collateralRequirement.actionAmount = _actionAmount;\\n        collateralRequirement.challengeAmount = _challengeAmount;\\n        collateralRequirement.staking = staking;\\n\\n        emit CollateralRequirementChanged(_disputable, id);\\n    }\\n\\n    /**\\n    * @dev Pay transactions fees required for new actions\\n    * @param _setting Agreement setting instance, used to get Aragon App Fees Cashier\\n    * @param _disputable Address of the Disputable app, used to determine fees\\n    * @param _submitter Address that submitted the action\\n    * @param _actionId Identification number of the action being paid for\\n    */\\n    function _payAppFees(Setting storage _setting, DisputableAragonApp _disputable, address _submitter, uint256 _actionId) internal {\\n        // Get fees\\n        IAragonAppFeesCashier aragonAppFeesCashier = _setting.aragonAppFeesCashier;\\n        if (aragonAppFeesCashier == IAragonAppFeesCashier(0)) {\\n            return;\\n        }\\n\\n        bytes32 appId = _disputable.appId();\\n        (ERC20 token, uint256 amount) = aragonAppFeesCashier.getAppFee(appId);\\n\\n        if (amount == 0) {\\n            return;\\n        }\\n\\n        // Pull the required amount from the fee token's staking pool and approve them to the cashier\\n        IStaking staking = stakingFactory.getOrCreateInstance(token);\\n        _lockBalance(staking, _submitter, amount);\\n        _slashBalance(staking, _submitter, address(this), amount);\\n        _approveFor(token, address(aragonAppFeesCashier), amount);\\n\\n        // Pay fees\\n        aragonAppFeesCashier.payAppFees(appId, abi.encodePacked(_actionId));\\n    }\\n\\n    /**\\n    * @dev Close an action\\n    *      This function does not perform any checks about the action status; callers must have already ensured the action can be closed.\\n    * @param _actionId Identification number of the action being closed\\n    * @param _action Action instance being closed\\n    */\\n    function _unsafeCloseAction(uint256 _actionId, Action storage _action) internal {\\n        _action.closed = true;\\n        emit ActionClosed(_actionId);\\n    }\\n\\n    /**\\n    * @dev Challenge an action\\n    * @param _actionId Identification number of the action being challenged\\n    * @param _action Action instance being challenged\\n    * @param _challenger Address challenging the action\\n    * @param _requirement Collateral requirement instance applicable to the challenge\\n    * @param _settlementOffer Amount of collateral tokens the challenger would accept for resolving the dispute without involving the arbitrator\\n    * @param _finishedSubmittingEvidence Whether the challenger is finished submitting evidence with the challenge context\\n    * @param _context Link to a human-readable context for the challenge\\n    * @return Identification number for the created challenge\\n    */\\n    function _createChallenge(\\n        uint256 _actionId,\\n        Action storage _action,\\n        address _challenger,\\n        CollateralRequirement storage _requirement,\\n        uint256 _settlementOffer,\\n        bool _finishedSubmittingEvidence,\\n        bytes _context\\n    )\\n        internal\\n        returns (uint256)\\n    {\\n        // Store challenge\\n        uint256 challengeId = nextChallengeId++;\\n        Challenge storage challenge = challenges[challengeId];\\n        challenge.actionId = _actionId;\\n        challenge.challenger = _challenger;\\n        challenge.endDate = getTimestamp64().add(_requirement.challengeDuration);\\n        challenge.context = _context;\\n        challenge.settlementOffer = _settlementOffer;\\n        challenge.challengerFinishedEvidence = _finishedSubmittingEvidence;\\n\\n        // Pull challenge collateral\\n        _depositFrom(_requirement.token, _challenger, _requirement.challengeAmount);\\n\\n        // Pull pre-paid arbitrator fees from challenger\\n        IArbitrator arbitrator = _getArbitratorFor(_action);\\n        (, ERC20 feeToken, uint256 feeAmount) = arbitrator.getDisputeFees();\\n        challenge.challengerArbitratorFees.token = feeToken;\\n        challenge.challengerArbitratorFees.amount = feeAmount;\\n        _depositFrom(feeToken, _challenger, feeAmount);\\n\\n        return challengeId;\\n    }\\n\\n    /**\\n    * @dev Dispute an action\\n    * @param _action Action instance being disputed\\n    * @param _challenge Currently open challenge instance for the action\\n    * @return _arbitrator Address of the IArbitrator applicable to the action\\n    * @return _metadata Metadata content to be used for the dispute\\n    * @return Identification number of the dispute created on the arbitrator\\n    */\\n    function _createDispute(Action storage _action, Challenge storage _challenge, IArbitrator _arbitrator, bytes memory _metadata)\\n        internal\\n        returns (uint256)\\n    {\\n        // Pull arbitration fees from submitter\\n        (address disputeFeeRecipient, ERC20 feeToken, uint256 feeAmount) = _arbitrator.getDisputeFees();\\n        _challenge.submitterArbitratorFees.token = feeToken;\\n        _challenge.submitterArbitratorFees.amount = feeAmount;\\n\\n        address submitter = _action.submitter;\\n        _depositFrom(feeToken, submitter, feeAmount);\\n\\n        // Create dispute. The arbitrator should pull its arbitration fees (if any) from this Agreement on `createDispute()`.\\n        _approveFor(feeToken, disputeFeeRecipient, feeAmount);\\n        uint256 disputeId = _arbitrator.createDispute(DISPUTES_POSSIBLE_OUTCOMES, _metadata);\\n\\n        return disputeId;\\n    }\\n\\n    /**\\n    * @dev Reject an action (\\\"accept challenge\\\")\\n    * @param _actionId Identification number of the action to be rejected\\n    * @param _action Action instance to be rejected\\n    * @param _challengeId Current challenge identification number for the action\\n    * @param _challenge Current challenge instance for the action\\n    */\\n    function _rejectAction(uint256 _actionId, Action storage _action, uint256 _challengeId, Challenge storage _challenge) internal {\\n        _challenge.state = ChallengeState.Accepted;\\n\\n        address challenger = _challenge.challenger;\\n        (DisputableAragonApp disputable, CollateralRequirement storage requirement) = _getDisputableInfoFor(_action);\\n\\n        // Transfer action collateral, challenge collateral, and challenger arbitrator fees to the challenger\\n        _slashBalance(requirement.staking, _action.submitter, challenger, requirement.actionAmount);\\n        _transferTo(requirement.token, challenger, requirement.challengeAmount);\\n        _transferTo(_challenge.challengerArbitratorFees.token, challenger, _challenge.challengerArbitratorFees.amount);\\n        disputable.onDisputableActionRejected(_action.disputableActionId);\\n        emit ActionRejected(_actionId, _challengeId);\\n        _unsafeCloseAction(_actionId, _action);\\n    }\\n\\n    /**\\n    * @dev Accept an action (\\\"reject challenge\\\")\\n    * @param _actionId Identification number of the action to be accepted\\n    * @param _action Action instance to be accepted\\n    * @param _challengeId Current challenge identification number for the action\\n    * @param _challenge Current challenge instance for the action\\n    */\\n    function _acceptAction(uint256 _actionId, Action storage _action, uint256 _challengeId, Challenge storage _challenge) internal {\\n        _challenge.state = ChallengeState.Rejected;\\n\\n        address submitter = _action.submitter;\\n        (DisputableAragonApp disputable, CollateralRequirement storage requirement) = _getDisputableInfoFor(_action);\\n\\n        // Transfer challenge collateral and challenger arbitrator fees to the submitter\\n        _transferTo(requirement.token, submitter, requirement.challengeAmount);\\n        _transferTo(_challenge.challengerArbitratorFees.token, submitter, _challenge.challengerArbitratorFees.amount);\\n        disputable.onDisputableActionAllowed(_action.disputableActionId);\\n        emit ActionAccepted(_actionId, _challengeId);\\n\\n        // Note that the action still continues after this ruling and will be closed at a future date\\n    }\\n\\n    /**\\n    * @dev Void an action (\\\"void challenge\\\")\\n    * @param _actionId Identification number of the action to be voided\\n    * @param _action Action instance to be voided\\n    * @param _challengeId Current challenge identification number for the action\\n    * @param _challenge Current challenge instance for the action\\n    */\\n    function _voidAction(uint256 _actionId, Action storage _action, uint256 _challengeId, Challenge storage _challenge) internal {\\n        _challenge.state = ChallengeState.Voided;\\n\\n        (DisputableAragonApp disputable, CollateralRequirement storage requirement) = _getDisputableInfoFor(_action);\\n        address challenger = _challenge.challenger;\\n\\n        // Return challenge collateral to the challenger, and split the challenger arbitrator fees between the challenger and the submitter\\n        _transferTo(requirement.token, challenger, requirement.challengeAmount);\\n        ERC20 challengerArbitratorFeesToken = _challenge.challengerArbitratorFees.token;\\n        uint256 challengerArbitratorFeesAmount = _challenge.challengerArbitratorFees.amount;\\n        uint256 submitterPayBack = challengerArbitratorFeesAmount / 2;\\n        // No need for Safemath because of previous computation\\n        uint256 challengerPayBack = challengerArbitratorFeesAmount - submitterPayBack;\\n        _transferTo(challengerArbitratorFeesToken, _action.submitter, submitterPayBack);\\n        _transferTo(challengerArbitratorFeesToken, challenger, challengerPayBack);\\n        disputable.onDisputableActionVoided(_action.disputableActionId);\\n        emit ActionVoided(_actionId, _challengeId);\\n\\n        // Note that the action still continues after this ruling and will be closed at a future date\\n    }\\n\\n    /**\\n    * @dev Lock some tokens in the staking pool for a user\\n    * @param _staking Staking pool for the ERC20 token to be locked\\n    * @param _user Address of the user to lock tokens for\\n    * @param _amount Amount of collateral tokens to be locked\\n    */\\n    function _lockBalance(IStaking _staking, address _user, uint256 _amount) internal {\\n        if (_amount == 0) {\\n            return;\\n        }\\n\\n        _staking.lock(_user, _amount);\\n    }\\n\\n    /**\\n    * @dev Unlock some tokens in the staking pool for a user\\n    * @param _staking Staking pool for the ERC20 token to be unlocked\\n    * @param _user Address of the user to unlock tokens for\\n    * @param _amount Amount of collateral tokens to be unlocked\\n    */\\n    function _unlockBalance(IStaking _staking, address _user, uint256 _amount) internal {\\n        if (_amount == 0) {\\n            return;\\n        }\\n\\n        _staking.unlock(_user, address(this), _amount);\\n    }\\n\\n    /**\\n    * @dev Slash some tokens in the staking pool from a user to a recipient\\n    * @param _staking Staking pool for the ERC20 token to be slashed\\n    * @param _user Address of the user to be slashed\\n    * @param _recipient Address receiving the slashed tokens\\n    * @param _amount Amount of collateral tokens to be slashed\\n    */\\n    function _slashBalance(IStaking _staking, address _user, address _recipient, uint256 _amount) internal {\\n        if (_amount == 0) {\\n            return;\\n        }\\n\\n        _staking.slashAndUnstake(_user, _recipient, _amount);\\n    }\\n\\n    /**\\n    * @dev Transfer tokens to an address\\n    * @param _token ERC20 token to be transferred\\n    * @param _to Address receiving the tokens\\n    * @param _amount Amount of tokens to be transferred\\n    */\\n    function _transferTo(ERC20 _token, address _to, uint256 _amount) internal {\\n        if (_amount > 0) {\\n            require(_token.safeTransfer(_to, _amount), ERROR_TOKEN_TRANSFER_FAILED);\\n        }\\n    }\\n\\n    /**\\n    * @dev Deposit tokens from an address to this Agreement\\n    * @param _token ERC20 token to be transferred\\n    * @param _from Address transferring the tokens\\n    * @param _amount Amount of tokens to be transferred\\n    */\\n    function _depositFrom(ERC20 _token, address _from, uint256 _amount) internal {\\n        if (_amount > 0) {\\n            require(_token.safeTransferFrom(_from, address(this), _amount), ERROR_TOKEN_DEPOSIT_FAILED);\\n        }\\n    }\\n\\n    /**\\n    * @dev Approve tokens held by this Agreement to another address\\n    * @param _token ERC20 token used for the arbitration fees\\n    * @param _to Address to be approved\\n    * @param _amount Amount of `_arbitrationFeeToken` tokens to be approved\\n    */\\n    function _approveFor(ERC20 _token, address _to, uint256 _amount) internal {\\n        if (_amount > 0) {\\n            // To be safe, we first set the allowance to zero in case there is a remaining approval for the arbitrator.\\n            // This is not strictly necessary for ERC20s, but some tokens, e.g. MiniMe (ANT and ANJ),\\n            // revert on an approval if an outstanding allowance exists\\n            require(_token.safeApprove(_to, 0), ERROR_TOKEN_APPROVAL_FAILED);\\n            require(_token.safeApprove(_to, _amount), ERROR_TOKEN_APPROVAL_FAILED);\\n        }\\n    }\\n\\n    /**\\n    * @dev Fetch an agreement setting instance by identification number\\n    * @param _settingId Identification number of the agreement setting\\n    * @return Agreement setting instance associated to the given identification number\\n    */\\n    function _getSetting(uint256 _settingId) internal view returns (Setting storage) {\\n        require(_settingId > 0 && _settingId < nextSettingId, ERROR_SETTING_DOES_NOT_EXIST);\\n        return settings[_settingId];\\n    }\\n\\n    /**\\n    * @dev Tell the identification number of the current agreement setting\\n    * @return Identification number of the current agreement setting\\n    */\\n    function _getCurrentSettingId() internal view returns (uint256) {\\n        // An initial setting is created during initialization, thus after initialization, length will be always greater than 0\\n        return nextSettingId == 0 ? 0 : nextSettingId - 1;\\n    }\\n\\n    /**\\n    * @dev Tell the arbitrator to be used for an action\\n    * @param _action Action instance\\n    * @return arbitrator Address of the IArbitrator that will be used to resolve disputes\\n    */\\n    function _getArbitratorFor(Action storage _action) internal view returns (IArbitrator) {\\n        Setting storage setting = _getSetting(_action.settingId);\\n        return setting.arbitrator;\\n    }\\n\\n    /**\\n    * @dev Tell the app fees cashier instance associated to an arbitrator\\n    * @param _arbitrator Arbitrator querying the app fees cashier for\\n    * @return Address of the app fees cashier associated to the arbitrator\\n    */\\n    function _getArbitratorFeesCashier(IArbitrator _arbitrator) internal view returns (IAragonAppFeesCashier) {\\n        (address cashier,,) = _arbitrator.getSubscriptionFees(address(this));\\n        return IAragonAppFeesCashier(cashier);\\n    }\\n\\n    /**\\n    * @dev Ensure a Disputable app is activate\\n    * @param _disputableInfo Disputable info of the app\\n    */\\n    function _ensureActiveDisputable(DisputableInfo storage _disputableInfo) internal view {\\n        require(_disputableInfo.activated, ERROR_DISPUTABLE_NOT_ACTIVE);\\n    }\\n\\n    /**\\n    * @dev Ensure a Disputable app is inactive\\n    * @param _disputableInfo Disputable info of the app\\n    */\\n    function _ensureInactiveDisputable(DisputableInfo storage _disputableInfo) internal view {\\n        require(!_disputableInfo.activated, ERROR_DISPUTABLE_ALREADY_ACTIVE);\\n    }\\n\\n    /**\\n    * @dev Tell the disputable-related information about an action\\n    * @param _action Action instance\\n    * @return disputable Address of the Disputable app associated to the action\\n    * @return requirement Collateral requirement instance applicable to the action\\n    */\\n    function _getDisputableInfoFor(Action storage _action)\\n        internal\\n        view\\n        returns (DisputableAragonApp disputable, CollateralRequirement storage requirement)\\n    {\\n        disputable = _action.disputable;\\n        DisputableInfo storage disputableInfo = disputableInfos[address(disputable)];\\n        requirement = _getCollateralRequirement(disputableInfo, _action.collateralRequirementId);\\n    }\\n\\n    /**\\n    * @dev Fetch the collateral requirement instance by identification number for a Disputable app\\n    * @param _disputableInfo Disputable info instance\\n    * @param _collateralRequirementId Identification number of the collateral requirement\\n    * @return Collateral requirement instance associated to the given identification number\\n    */\\n    function _getCollateralRequirement(DisputableInfo storage _disputableInfo, uint256 _collateralRequirementId)\\n        internal\\n        view\\n        returns (CollateralRequirement storage)\\n    {\\n        bool exists = _collateralRequirementId > 0 && _collateralRequirementId < _disputableInfo.nextCollateralRequirementsId;\\n        require(exists, ERROR_COLLATERAL_REQUIREMENT_DOES_NOT_EXIST);\\n        return _disputableInfo.collateralRequirements[_collateralRequirementId];\\n    }\\n\\n    /**\\n    * @dev Tell the information related to a signer\\n    * @param _signer Address of signer\\n    * @return lastSettingIdSigned Identification number of the last agreement setting signed by the signer\\n    * @return mustSign Whether the signer needs to sign the current agreement setting before submitting an action\\n    */\\n    function _getSigner(address _signer) internal view returns (uint256 lastSettingIdSigned, bool mustSign) {\\n        lastSettingIdSigned = lastSettingSignedBy[_signer];\\n        mustSign = lastSettingIdSigned < _getCurrentSettingId();\\n    }\\n\\n    /**\\n    * @dev Fetch an action instance by identification number\\n    * @param _actionId Identification number of the action\\n    * @return Action instance associated to the given identification number\\n    */\\n    function _getAction(uint256 _actionId) internal view returns (Action storage) {\\n        require(_actionId > 0 && _actionId < nextActionId, ERROR_ACTION_DOES_NOT_EXIST);\\n        return actions[_actionId];\\n    }\\n\\n    /**\\n    * @dev Fetch a challenge instance by identification number\\n    * @param _challengeId Identification number of the challenge\\n    * @return Challenge instance associated to the given identification number\\n    */\\n    function _getChallenge(uint256 _challengeId) internal view returns (Challenge storage) {\\n        require(_existChallenge(_challengeId), ERROR_CHALLENGE_DOES_NOT_EXIST);\\n        return challenges[_challengeId];\\n    }\\n\\n    /**\\n    * @dev Fetch an action instance along with its most recent challenge by identification number\\n    * @param _actionId Identification number of the action\\n    * @return action Action instance associated to the given identification number\\n    * @return challenge Most recent challenge instance associated to the action\\n    * @return challengeId Identification number of the most recent challenge associated to the action\\n    */\\n    function _getChallengedAction(uint256 _actionId)\\n        internal\\n        view\\n        returns (Action storage action, Challenge storage challenge, uint256 challengeId)\\n    {\\n        action = _getAction(_actionId);\\n        challengeId = action.lastChallengeId;\\n        challenge = _getChallenge(challengeId);\\n    }\\n\\n    /**\\n    * @dev Fetch a dispute's associated action and challenge instance\\n    * @param _disputeId Identification number of the dispute on the arbitrator\\n    * @return actionId Identification number of the action associated to the dispute\\n    * @return action Action instance associated to the dispute\\n    * @return challengeId Identification number of the challenge associated to the dispute\\n    * @return challenge Current challenge instance associated to the dispute\\n    */\\n    function _getDisputedAction(uint256 _disputeId)\\n        internal\\n        view\\n        returns (uint256 actionId, Action storage action, uint256 challengeId, Challenge storage challenge)\\n    {\\n        challengeId = challengeByDispute[_disputeId];\\n        challenge = _getChallenge(challengeId);\\n        actionId = challenge.actionId;\\n        action = _getAction(actionId);\\n    }\\n\\n    /**\\n    * @dev Tell whether a challenge exists\\n    * @param _challengeId Identification number of the challenge\\n    * @return True if the requested challenge exists, false otherwise\\n    */\\n    function _existChallenge(uint256 _challengeId) internal view returns (bool) {\\n        return _challengeId > 0 && _challengeId < nextChallengeId;\\n    }\\n\\n    /**\\n    * @dev Tell whether an action can be manually closed\\n    * @param _action Action instance\\n    * @return True if the action can be closed, false otherwise\\n    */\\n    function _canClose(Action storage _action) internal view returns (bool) {\\n        if (!_canProceed(_action)) {\\n            return false;\\n        }\\n\\n        DisputableAragonApp disputable = _action.disputable;\\n        // Assume that the Disputable app does not need to be checked if it's the one asking us to close an action\\n        return DisputableAragonApp(msg.sender) == disputable || disputable.canClose(_action.disputableActionId);\\n    }\\n\\n    /**\\n    * @dev Tell whether an action can be challenged\\n    * @param _action Action instance\\n    * @return True if the action can be challenged, false otherwise\\n    */\\n    function _canChallenge(Action storage _action) internal view returns (bool) {\\n        return _canProceed(_action) && _action.disputable.canChallenge(_action.disputableActionId);\\n    }\\n\\n    /**\\n    * @dev Tell whether an action can proceed to another state.\\n    * @dev An action can proceed if it is:\\n    *       - Not closed\\n    *       - Not currently challenged or disputed, and\\n    *       - Not already settled or had a dispute rule in favour of the challenger (the action will have been closed automatically)\\n    * @param _action Action instance\\n    * @return True if the action can proceed, false otherwise\\n    */\\n    function _canProceed(Action storage _action) internal view returns (bool) {\\n        // If the action was already closed, return false\\n        if (_action.closed) {\\n            return false;\\n        }\\n\\n        uint256 challengeId = _action.lastChallengeId;\\n\\n        // If the action has not been challenged yet, return true\\n        if (!_existChallenge(challengeId)) {\\n            return true;\\n        }\\n\\n        // If the action was previously challenged but ruled in favour of the submitter or voided, return true\\n        Challenge storage challenge = challenges[challengeId];\\n        ChallengeState state = challenge.state;\\n        return state == ChallengeState.Rejected || state == ChallengeState.Voided;\\n    }\\n\\n    /**\\n    * @dev Tell whether a challenge can be settled\\n    * @param _challenge Challenge instance\\n    * @return True if the challenge can be settled, false otherwise\\n    */\\n    function _canSettle(Challenge storage _challenge) internal view returns (bool) {\\n        return _isWaitingChallengeAnswer(_challenge);\\n    }\\n\\n    /**\\n    * @dev Tell whether a challenge settlement can be claimed\\n    * @param _challenge Challenge instance\\n    * @return True if the challenge settlement can be claimed, false otherwise\\n    */\\n    function _canClaimSettlement(Challenge storage _challenge) internal view returns (bool) {\\n        return _isWaitingChallengeAnswer(_challenge) && getTimestamp() >= uint256(_challenge.endDate);\\n    }\\n\\n    /**\\n    * @dev Tell whether a challenge can be disputed\\n    * @param _challenge Challenge instance\\n    * @return True if the challenge can be disputed, false otherwise\\n    */\\n    function _canDispute(Challenge storage _challenge) internal view returns (bool) {\\n        return _isWaitingChallengeAnswer(_challenge) && uint256(_challenge.endDate) > getTimestamp();\\n    }\\n\\n    /**\\n    * @dev Tell whether a challenge is waiting to be answered\\n    * @param _challenge Challenge instance\\n    * @return True if the challenge is waiting to be answered, false otherwise\\n    */\\n    function _isWaitingChallengeAnswer(Challenge storage _challenge) internal view returns (bool) {\\n        return _challenge.state == ChallengeState.Waiting;\\n    }\\n\\n    /**\\n    * @dev Tell whether a challenge is disputed\\n    * @param _challenge Challenge instance\\n    * @return True if the challenge is disputed, false otherwise\\n    */\\n    function _isDisputed(Challenge storage _challenge) internal view returns (bool) {\\n        return _challenge.state == ChallengeState.Disputed;\\n    }\\n\\n    /**\\n    * @dev Tell whether an address has permission to challenge actions on a specific Disputable app\\n    * @param _disputable Address of the Disputable app\\n    * @param _challenger Address of the challenger\\n    * @return True if the challenger can challenge actions on the Disputable app, false otherwise\\n    */\\n    function _canPerformChallenge(DisputableAragonApp _disputable, address _challenger) internal view returns (bool) {\\n        IKernel currentKernel = kernel();\\n        if (currentKernel == IKernel(0)) {\\n            return false;\\n        }\\n\\n        // To make sure the challenger address is reachable by ACL oracles, we need to pass it as the first argument.\\n        // Permissions set with ANY_ENTITY do not provide the original sender's address into the ACL Oracle's `grantee` argument.\\n        bytes memory params = ConversionHelpers.dangerouslyCastUintArrayToBytes(arr(_challenger));\\n        return currentKernel.hasPermission(_challenger, address(_disputable), CHALLENGE_ROLE, params);\\n    }\\n}\\n\",\"keccak256\":\"0xfca7e9867c3093815de0606a4bca861f2ea016a53f5bcc0b40e5a235f6a205f3\"},\"contracts/arbitration/IAragonAppFeesCashier.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"@aragon/os/contracts/lib/token/ERC20.sol\\\";\\n\\n\\n/**\\n* @title AragonAppFeesCashier interface\\n* @dev This interface is derived from the `IArbitrator`'s subscriptions module.\\n*      It is used to pay the fees corresponding to the usage of a disputable app.\\n*      This interface was manually-copied from https://github.com/aragon/aragon-court/blob/v1.2.0/contracts/subscriptions/IAragonAppFeesCashier.sol\\n*      since we are using different solidity versions.\\n*/\\ninterface IAragonAppFeesCashier {\\n    /**\\n    * @dev Emitted when an IAragonAppFeesCashier instance sets a new fee for an app\\n    * @param appId App identifier\\n    * @param token Token address to be used for the fees\\n    * @param amount Fee amount to be charged for the given app\\n    */\\n    event AppFeeSet(bytes32 indexed appId, ERC20 token, uint256 amount);\\n\\n    /**\\n    * @dev Emitted when an IAragonAppFeesCashier instance unsets an app fee\\n    * @param appId App identifier\\n    */\\n    event AppFeeUnset(bytes32 indexed appId);\\n\\n    /**\\n    * @dev Emitted when an IAragonAppFeesCashier instance receives a payment for an app\\n    * @param by Address paying the fees\\n    * @param appId App identifier\\n    * @param data Optional data\\n    */\\n    event AppFeePaid(address indexed by, bytes32 appId, bytes data);\\n\\n    /**\\n    * @dev Set the fee amount and token to be used for an app\\n    * @param _appId App identifier\\n    * @param _token Token address to be used for the fees\\n    * @param _amount Fee amount to be charged for the given app\\n    */\\n    function setAppFee(bytes32 _appId, ERC20 _token, uint256 _amount) external;\\n\\n    /**\\n    * @dev Set the fee amount and token to be used for a list of apps\\n    * @param _appIds List of app identifiers\\n    * @param _tokens List of token addresses to be used for the fees for each app\\n    * @param _amounts List of fee amounts to be charged for each app\\n    */\\n    function setAppFees(bytes32[] _appIds, ERC20[] _tokens, uint256[] _amounts) external;\\n\\n    /**\\n    * @dev Remove the fee set for an app\\n    * @param _appId App identifier\\n    */\\n    function unsetAppFee(bytes32 _appId) external;\\n\\n    /**\\n    * @dev Remove the fee set for a list of apps\\n    * @param _appIds List of app identifiers\\n    */\\n    function unsetAppFees(bytes32[] _appIds) external;\\n\\n    /**\\n    * @dev Pay the fees corresponding to an app\\n    * @param _appId App identifier\\n    * @param _data Optional data input\\n    */\\n    function payAppFees(bytes32 _appId, bytes _data) external payable;\\n\\n    /**\\n    * @dev Tell the fee token and amount set for a given app\\n    * @param _appId Identifier of the app being queried\\n    * @return token Fee token address set for the requested app\\n    * @return amount Fee token amount set for the requested app\\n    */\\n    function getAppFee(bytes32 _appId) external view returns (ERC20 token, uint256 amount);\\n}\\n\",\"keccak256\":\"0xcdaa5ef067945cdf0f5c47bb5b8c4e5fa1ab712c9faa3a4d5e255f1ecfeb8634\"},\"contracts/arbitration/IArbitrable.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./IArbitrator.sol\\\";\\n\\n\\n/**\\n* @title Arbitrable interface\\n* @dev This interface is implemented by `Agreement` so it can be used to submit disputes to an `IArbitrator`.\\n*      This interface was manually-copied from https://github.com/aragon/aragon-court/blob/v1.2.0/contracts/arbitration/IArbitrable.sol\\n*      since we are using different solidity versions.\\n*/\\ncontract IArbitrable {\\n    /**\\n    * @dev Emitted when an IArbitrable instance's dispute is ruled by an IArbitrator\\n    * @param arbitrator IArbitrator instance ruling the dispute\\n    * @param disputeId Identifier of the dispute being ruled by the arbitrator\\n    * @param ruling Ruling given by the arbitrator\\n    */\\n    event Ruled(IArbitrator indexed arbitrator, uint256 indexed disputeId, uint256 ruling);\\n}\\n\",\"keccak256\":\"0xc137e352dc8a7deee00775758a5a7f4b20ab68fa302502dbf3392a95e43bfbc3\"},\"contracts/arbitration/IArbitrator.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"@aragon/os/contracts/lib/token/ERC20.sol\\\";\\n\\n\\n/**\\n* @title Arbitrator interface\\n* @dev This interface is the one used by `Agreement` as its dispute resolution protocol.\\n*      This interface was manually-copied from https://github.com/aragon/aragon-court/blob/v1.2.0/contracts/arbitration/IArbitrator.sol\\n*      since we are using different solidity versions.\\n*/\\ninterface IArbitrator {\\n    /**\\n    * @dev Create a dispute over the Arbitrable sender with a number of possible rulings\\n    * @param _possibleRulings Number of possible rulings allowed for the dispute\\n    * @param _metadata Optional metadata that can be used to provide additional information on the dispute to be created\\n    * @return Dispute identification number\\n    */\\n    function createDispute(uint256 _possibleRulings, bytes _metadata) external returns (uint256);\\n\\n    /**\\n    * @dev Submit evidence for a dispute\\n    * @param _disputeId Id of the dispute in the Protocol\\n    * @param _submitter Address of the account submitting the evidence\\n    * @param _evidence Data submitted for the evidence related to the dispute\\n    */\\n    function submitEvidence(uint256 _disputeId, address _submitter, bytes _evidence) external;\\n\\n    /**\\n    * @dev Close the evidence period of a dispute\\n    * @param _disputeId Identification number of the dispute to close its evidence submitting period\\n    */\\n    function closeEvidencePeriod(uint256 _disputeId) external;\\n\\n    /**\\n    * @notice Rule dispute #`_disputeId` if ready\\n    * @param _disputeId Identification number of the dispute to be ruled\\n    * @return subject Arbitrable instance associated to the dispute\\n    * @return ruling Ruling number computed for the given dispute\\n    */\\n    function rule(uint256 _disputeId) external returns (address subject, uint256 ruling);\\n\\n    /**\\n    * @dev Tell the dispute fees information to create a dispute\\n    * @return recipient Address where the corresponding dispute fees must be transferred to\\n    * @return feeToken ERC20 token used for the fees\\n    * @return feeAmount Total amount of fees that must be allowed to the recipient\\n    */\\n    function getDisputeFees() external view returns (address recipient, ERC20 feeToken, uint256 feeAmount);\\n\\n    /**\\n    * @dev Tell the subscription fees information for a subscriber to be up-to-date\\n    * @param _subscriber Address of the account paying the subscription fees for\\n    * @return recipient Address where the corresponding subscriptions fees must be transferred to\\n    * @return feeToken ERC20 token used for the subscription fees\\n    * @return feeAmount Total amount of fees that must be allowed to the recipient\\n    */\\n    function getSubscriptionFees(address _subscriber) external view returns (address recipient, ERC20 feeToken, uint256 feeAmount);\\n}\\n\",\"keccak256\":\"0x2bee124cc184391fe74b6767e213dccb94cacf00e8e8ce1bf7a432096a1b79c8\"},\"contracts/collateralUpdater/CollateralRequirementUpdater.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"openzeppelin-solidity/contracts/ownership/Ownable.sol\\\";\\nimport \\\"../Agreement.sol\\\";\\nimport \\\"./PriceOracle.sol\\\";\\n\\ncontract CollateralRequirementUpdater is Ownable {\\n\\n    uint256 constant public MAX_DISPUTABLE_APPS = 10;\\n\\n    Agreement public agreement;\\n    DisputableAragonApp[] public disputableApps;\\n    ERC20[] public collateralTokens;\\n    uint256[] public actionAmountsStable;\\n    uint256[] public challengeAmountsStable;\\n    PriceOracle public priceOracle;\\n    address public stableToken;\\n\\n    event CollateralRequirementsUpdated();\\n    event ActionAndChallengeAmountsUpdated();\\n\\n    constructor(\\n        Agreement _agreement,\\n        DisputableAragonApp[] _disputableApps,\\n        ERC20[] _collateralTokens,\\n        uint256[] _actionAmountsStable,\\n        uint256[] _challengeAmountsStable,\\n        PriceOracle _priceOracle,\\n        address _stableToken\\n    ) public {\\n        require(_disputableApps.length == _collateralTokens.length\\n            && _actionAmountsStable.length == _challengeAmountsStable.length\\n            && _collateralTokens.length == _actionAmountsStable.length, \\\"ERROR: Inconsistently sized arrays\\\");\\n        require(_disputableApps.length <= MAX_DISPUTABLE_APPS, \\\"ERROR: Too many disputable apps\\\");\\n\\n        agreement = _agreement;\\n        disputableApps = _disputableApps;\\n        collateralTokens = _collateralTokens;\\n        actionAmountsStable = _actionAmountsStable;\\n        challengeAmountsStable = _challengeAmountsStable;\\n        priceOracle = _priceOracle;\\n        stableToken = _stableToken;\\n    }\\n\\n    // This contract requires the MANAGE_DISPUTABLE_ROLE permission on the specified Agreement contract\\n    function updateCollateralRequirements() external {\\n        for (uint256 i = 0; i < disputableApps.length; i++) {\\n            DisputableAragonApp disputableAragonApp = disputableApps[i];\\n            (, uint256 currentCollateralRequirementId) = agreement.getDisputableInfo(disputableAragonApp);\\n            (ERC20 collateralToken, uint64 challengeDuration, uint256 actionAmount, uint256 challengeAmount)\\n                = agreement.getCollateralRequirement(disputableAragonApp, currentCollateralRequirementId);\\n\\n            require(collateralToken == collateralTokens[i], \\\"ERROR: Collateral tokens do not match\\\");\\n\\n            uint256 actionAmountVariable = priceOracle.consult(stableToken, actionAmountsStable[i], collateralToken);\\n            uint256 challengeAmountVariable = priceOracle.consult(stableToken, challengeAmountsStable[i], collateralToken);\\n\\n            require(actionAmount != actionAmountVariable || challengeAmount != challengeAmountVariable, \\\"ERROR: No update needed\\\");\\n\\n            agreement.changeCollateralRequirement(disputableAragonApp, collateralToken, challengeDuration,\\n                actionAmountVariable, challengeAmountVariable);\\n        }\\n\\n        emit CollateralRequirementsUpdated();\\n    }\\n\\n    function updateActionAndChallengeAmount(\\n        uint256[] _actionAmountsStable,\\n        uint256[] _challengeAmountsStable\\n    ) external onlyOwner {\\n        require(_actionAmountsStable.length == _challengeAmountsStable.length\\n        && _actionAmountsStable.length == actionAmountsStable.length, \\\"ERROR: Inconsistently sized arrays\\\");\\n\\n        actionAmountsStable = _actionAmountsStable;\\n        challengeAmountsStable = _challengeAmountsStable;\\n\\n        emit ActionAndChallengeAmountsUpdated();\\n    }\\n}\\n\",\"keccak256\":\"0xf50705abce650b928adb05e8a8a7a3d2beb5e8cef4fa1b817eedfb492086e932\"},\"contracts/collateralUpdater/CollateralRequirementUpdaterFactory.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./CollateralRequirementUpdater.sol\\\";\\n\\n// Rinkeby deployment: 0x4c4B2EE79D42d21E76045b0d7B2f9DD0e951F4Ed\\n// xDai deployment: 0x186F0bF13D2C1D06eBB296aaE0eaB9A5008f776D\\n\\ncontract CollateralRequirementUpdaterFactory {\\n\\n    event NewCollateralRequirementUpdater(CollateralRequirementUpdater _newCollateralRequirementUpdater);\\n\\n    function newCollateralRequirementUpdater(\\n        Agreement _agreement,\\n        DisputableAragonApp[] _disputableApps,\\n        ERC20[] _collateralTokens,\\n        uint256[] _actionAmountsStable,\\n        uint256[] _challengeAmountsStable,\\n        PriceOracle _priceOracle,\\n        address _stableToken\\n    ) public returns (address) {\\n        CollateralRequirementUpdater collateralRequirementUpdater = new CollateralRequirementUpdater(\\n            _agreement,\\n            _disputableApps,\\n            _collateralTokens,\\n            _actionAmountsStable,\\n            _challengeAmountsStable,\\n            _priceOracle,\\n            _stableToken\\n        );\\n\\n        collateralRequirementUpdater.transferOwnership(msg.sender);\\n\\n        emit NewCollateralRequirementUpdater(collateralRequirementUpdater);\\n\\n        return collateralRequirementUpdater;\\n    }\\n}\\n\",\"keccak256\":\"0x56c40ee2e5a4d6902da1c3927a101ba031cbe471067cae69ebc66af589719a89\"},\"contracts/collateralUpdater/PriceOracle.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\ncontract PriceOracle {\\n\\n    function consult(address tokenIn, uint amountIn, address tokenOut) external view returns (uint amountOut);\\n\\n}\\n\",\"keccak256\":\"0x557318bca55027a72259da66d0f740d91c90e4506bb21e181b352e765849936f\"},\"openzeppelin-solidity/contracts/ownership/Ownable.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n  address public owner;\\n\\n\\n  event OwnershipRenounced(address indexed previousOwner);\\n  event OwnershipTransferred(\\n    address indexed previousOwner,\\n    address indexed newOwner\\n  );\\n\\n\\n  /**\\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n   * account.\\n   */\\n  constructor() public {\\n    owner = msg.sender;\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    require(msg.sender == owner);\\n    _;\\n  }\\n\\n  /**\\n   * @dev Allows the current owner to relinquish control of the contract.\\n   * @notice Renouncing to ownership will leave the contract without an owner.\\n   * It will not be possible to call the functions with the `onlyOwner`\\n   * modifier anymore.\\n   */\\n  function renounceOwnership() public onlyOwner {\\n    emit OwnershipRenounced(owner);\\n    owner = address(0);\\n  }\\n\\n  /**\\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n   * @param _newOwner The address to transfer ownership to.\\n   */\\n  function transferOwnership(address _newOwner) public onlyOwner {\\n    _transferOwnership(_newOwner);\\n  }\\n\\n  /**\\n   * @dev Transfers control of the contract to a newOwner.\\n   * @param _newOwner The address to transfer ownership to.\\n   */\\n  function _transferOwnership(address _newOwner) internal {\\n    require(_newOwner != address(0));\\n    emit OwnershipTransferred(owner, _newOwner);\\n    owner = _newOwner;\\n  }\\n}\\n\",\"keccak256\":\"0x84c7090c27cf3657b73d9e26b6b316975fa0bd233b8169f254de0c3b3acfaefc\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506113e3806100206000396000f3006080604052600436106100405763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166339de624f8114610045575b600080fd5b34801561005157600080fd5b5060408051602060046024803582810135848102808701860190975280865261018396843573ffffffffffffffffffffffffffffffffffffffff1696369660449591949091019291829185019084908082843750506040805187358901803560208181028481018201909552818452989b9a998901989297509082019550935083925085019084908082843750506040805187358901803560208181028481018201909552818452989b9a998901989297509082019550935083925085019084908082843750506040805187358901803560208181028481018201909552818452989b9a9989019892975090820195509350839250850190849080828437509497505073ffffffffffffffffffffffffffffffffffffffff85358116965060209095013590941693506101ac92505050565b6040805173ffffffffffffffffffffffffffffffffffffffff9092168252519081900360200190f35b600080888888888888886101be610401565b73ffffffffffffffffffffffffffffffffffffffff808916825283811660a0830152821660c082015260e0602080830182815289519284019290925288516040840191606085019160808601916101008701918d8201910280838360005b8381101561023457818101518382015260200161021c565b5050505090500185810384528a818151815260200191508051906020019060200280838360005b8381101561027357818101518382015260200161025b565b50505050905001858103835289818151815260200191508051906020019060200280838360005b838110156102b257818101518382015260200161029a565b50505050905001858103825288818151815260200191508051906020019060200280838360005b838110156102f15781810151838201526020016102d9565b505050509050019b505050505050505050505050604051809103906000f080158015610321573d6000803e3d6000fd5b50604080517ff2fde38b000000000000000000000000000000000000000000000000000000008152336004820152905191925073ffffffffffffffffffffffffffffffffffffffff83169163f2fde38b9160248082019260009290919082900301818387803b15801561039357600080fd5b505af11580156103a7573d6000803e3d6000fd5b50506040805173ffffffffffffffffffffffffffffffffffffffff8516815290517f3b9cfe7533d00c736ad7c2ea1d9f8c4d30713494730c1a9e3e6ba367eb55fa2b9350908190036020019150a198975050505050505050565b604051610fa68061041283390190560060806040523480156200001157600080fd5b5060405162000fa638038062000fa683398101604090815281516020830151918301516060840151608085015160a086015160c087015160008054600160a060020a03191633179055938701805196880180519698909791969481019593019391929114801562000083575082518451145b801562000091575083518551145b15156200012557604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f4552524f523a20496e636f6e73697374656e746c792073697a6564206172726160448201527f7973000000000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b8551600a10156200019757604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f4552524f523a20546f6f206d616e792064697370757461626c65206170707300604482015290519081900360640190fd5b60018054600160a060020a031916600160a060020a0389161790558551620001c790600290602089019062000242565b508451620001dd90600390602088019062000242565b508351620001f3906004906020870190620002ac565b50825162000209906005906020860190620002ac565b5060068054600160a060020a03938416600160a060020a03199182161790915560078054929093169116179055506200033f9350505050565b8280548282559060005260206000209081019282156200029a579160200282015b828111156200029a5782518254600160a060020a031916600160a060020a0390911617825560209092019160019091019062000263565b50620002a8929150620002f8565b5090565b828054828255906000526020600020908101928215620002ea579160200282015b82811115620002ea578251825591602001919060010190620002cd565b50620002a892915062000322565b6200031f91905b80821115620002a8578054600160a060020a0319168155600101620002ff565b90565b6200031f91905b80821115620002a8576000815560010162000329565b610c57806200034f6000396000f3006080604052600436106100c45763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416630d5f9eaa81146100c9578063172c48c7146100f05780632630c12f1461013157806334a2c87314610146578063715018a61461015e57806377072bf0146101755780637db3a9461461018a5780638da5cb5b1461019f578063a54f4e44146101b4578063a9d75b2b146101e0578063c1d92e67146101f5578063c7579c881461020d578063f2fde38b14610225575b600080fd5b3480156100d557600080fd5b506100de610253565b60408051918252519081900360200190f35b3480156100fc57600080fd5b50610108600435610258565b6040805173ffffffffffffffffffffffffffffffffffffffff9092168252519081900360200190f35b34801561013d57600080fd5b5061010861028d565b34801561015257600080fd5b506100de6004356102a9565b34801561016a57600080fd5b506101736102c8565b005b34801561018157600080fd5b5061017361034e565b34801561019657600080fd5b5061010861096f565b3480156101ab57600080fd5b5061010861098b565b3480156101c057600080fd5b5061017360246004803582810192908201359181359182019101356109a7565b3480156101ec57600080fd5b50610108610ab7565b34801561020157600080fd5b50610108600435610ad3565b34801561021957600080fd5b506100de600435610ae1565b34801561023157600080fd5b5061017373ffffffffffffffffffffffffffffffffffffffff60043516610aef565b600a81565b600380548290811061026657fe5b60009182526020909120015473ffffffffffffffffffffffffffffffffffffffff16905081565b60065473ffffffffffffffffffffffffffffffffffffffff1681565b60048054829081106102b757fe5b600091825260209091200154905081565b60005473ffffffffffffffffffffffffffffffffffffffff1633146102ec57600080fd5b6000805460405173ffffffffffffffffffffffffffffffffffffffff909116917ff8df31144d9c2f0f6b59d69b8b98abd5459d07f2742c4df920b25aae33c6482091a26000805473ffffffffffffffffffffffffffffffffffffffff19169055565b600080808080808080805b60025489101561093b57600280548a90811061037157fe5b6000918252602082200154600154604080517fb86472b100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff938416600482018190528251909d50929093169363b86472b19360248082019492918390030190829087803b1580156103f357600080fd5b505af1158015610407573d6000803e3d6000fd5b505050506040513d604081101561041d57600080fd5b5060200151600154604080517f221ce7c300000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8c81166004830152602482018590529151939a5091169163221ce7c3916044808201926080929091908290030181600087803b1580156104a057600080fd5b505af11580156104b4573d6000803e3d6000fd5b505050506040513d60808110156104ca57600080fd5b5080516020820151604083015160609093015160038054939a509198509296509194508a9081106104f757fe5b60009182526020909120015473ffffffffffffffffffffffffffffffffffffffff8781169116146105af57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602560248201527f4552524f523a20436f6c6c61746572616c20746f6b656e7320646f206e6f742060448201527f6d61746368000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b6006546007546004805473ffffffffffffffffffffffffffffffffffffffff93841693638c86f1e4931691908d9081106105e557fe5b9060005260206000200154896040518463ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018381526020018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019350505050602060405180830381600087803b1580156106a957600080fd5b505af11580156106bd573d6000803e3d6000fd5b505050506040513d60208110156106d357600080fd5b50516006546007546005805493955073ffffffffffffffffffffffffffffffffffffffff92831693638c86f1e493909216918d90811061070f57fe5b9060005260206000200154896040518463ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018381526020018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019350505050602060405180830381600087803b1580156107d357600080fd5b505af11580156107e7573d6000803e3d6000fd5b505050506040513d60208110156107fd57600080fd5b5051905083821415806108105750808314155b151561087d57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f4552524f523a204e6f20757064617465206e6565646564000000000000000000604482015290519081900360640190fd5b600154604080517f079239d400000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8b81166004830152898116602483015267ffffffffffffffff8916604483015260648201869052608482018590529151919092169163079239d49160a480830192600092919082900301818387803b15801561091757600080fd5b505af115801561092b573d6000803e3d6000fd5b50506001909a0199506103599050565b6040517f64ce29450ac1dca47339b74b17eeeaa0cdcd6143c5939f0a88b6cf5a68fa4fb990600090a1505050505050505050565b60015473ffffffffffffffffffffffffffffffffffffffff1681565b60005473ffffffffffffffffffffffffffffffffffffffff1681565b60005473ffffffffffffffffffffffffffffffffffffffff1633146109cb57600080fd5b82811480156109db575060045483145b1515610a6e57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f4552524f523a20496e636f6e73697374656e746c792073697a6564206172726160448201527f7973000000000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b610a7a60048585610bc3565b50610a8760058383610bc3565b506040517faad32b5df501118451f5325ab53c78d234bc6fb8e9e4e2ca0515e6784e09820f90600090a150505050565b60075473ffffffffffffffffffffffffffffffffffffffff1681565b600280548290811061026657fe5b60058054829081106102b757fe5b60005473ffffffffffffffffffffffffffffffffffffffff163314610b1357600080fd5b610b1c81610b1f565b50565b73ffffffffffffffffffffffffffffffffffffffff81161515610b4157600080fd5b6000805460405173ffffffffffffffffffffffffffffffffffffffff808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a36000805473ffffffffffffffffffffffffffffffffffffffff191673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b828054828255906000526020600020908101928215610bfe579160200282015b82811115610bfe578235825591602001919060010190610be3565b50610c0a929150610c0e565b5090565b610c2891905b80821115610c0a5760008155600101610c14565b905600a165627a7a7230582056e47ca7cfb2ec27e4c1964713d88a48ab022a46b5c2dcf7d0f4b50c5fab86020029a165627a7a7230582021d4375a25d27b9803407adf9c98d32048935dee057f62a5d0894dcb6dae7ee10029",
  "deployedBytecode": "0x6080604052600436106100405763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166339de624f8114610045575b600080fd5b34801561005157600080fd5b5060408051602060046024803582810135848102808701860190975280865261018396843573ffffffffffffffffffffffffffffffffffffffff1696369660449591949091019291829185019084908082843750506040805187358901803560208181028481018201909552818452989b9a998901989297509082019550935083925085019084908082843750506040805187358901803560208181028481018201909552818452989b9a998901989297509082019550935083925085019084908082843750506040805187358901803560208181028481018201909552818452989b9a9989019892975090820195509350839250850190849080828437509497505073ffffffffffffffffffffffffffffffffffffffff85358116965060209095013590941693506101ac92505050565b6040805173ffffffffffffffffffffffffffffffffffffffff9092168252519081900360200190f35b600080888888888888886101be610401565b73ffffffffffffffffffffffffffffffffffffffff808916825283811660a0830152821660c082015260e0602080830182815289519284019290925288516040840191606085019160808601916101008701918d8201910280838360005b8381101561023457818101518382015260200161021c565b5050505090500185810384528a818151815260200191508051906020019060200280838360005b8381101561027357818101518382015260200161025b565b50505050905001858103835289818151815260200191508051906020019060200280838360005b838110156102b257818101518382015260200161029a565b50505050905001858103825288818151815260200191508051906020019060200280838360005b838110156102f15781810151838201526020016102d9565b505050509050019b505050505050505050505050604051809103906000f080158015610321573d6000803e3d6000fd5b50604080517ff2fde38b000000000000000000000000000000000000000000000000000000008152336004820152905191925073ffffffffffffffffffffffffffffffffffffffff83169163f2fde38b9160248082019260009290919082900301818387803b15801561039357600080fd5b505af11580156103a7573d6000803e3d6000fd5b50506040805173ffffffffffffffffffffffffffffffffffffffff8516815290517f3b9cfe7533d00c736ad7c2ea1d9f8c4d30713494730c1a9e3e6ba367eb55fa2b9350908190036020019150a198975050505050505050565b604051610fa68061041283390190560060806040523480156200001157600080fd5b5060405162000fa638038062000fa683398101604090815281516020830151918301516060840151608085015160a086015160c087015160008054600160a060020a03191633179055938701805196880180519698909791969481019593019391929114801562000083575082518451145b801562000091575083518551145b15156200012557604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f4552524f523a20496e636f6e73697374656e746c792073697a6564206172726160448201527f7973000000000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b8551600a10156200019757604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f4552524f523a20546f6f206d616e792064697370757461626c65206170707300604482015290519081900360640190fd5b60018054600160a060020a031916600160a060020a0389161790558551620001c790600290602089019062000242565b508451620001dd90600390602088019062000242565b508351620001f3906004906020870190620002ac565b50825162000209906005906020860190620002ac565b5060068054600160a060020a03938416600160a060020a03199182161790915560078054929093169116179055506200033f9350505050565b8280548282559060005260206000209081019282156200029a579160200282015b828111156200029a5782518254600160a060020a031916600160a060020a0390911617825560209092019160019091019062000263565b50620002a8929150620002f8565b5090565b828054828255906000526020600020908101928215620002ea579160200282015b82811115620002ea578251825591602001919060010190620002cd565b50620002a892915062000322565b6200031f91905b80821115620002a8578054600160a060020a0319168155600101620002ff565b90565b6200031f91905b80821115620002a8576000815560010162000329565b610c57806200034f6000396000f3006080604052600436106100c45763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416630d5f9eaa81146100c9578063172c48c7146100f05780632630c12f1461013157806334a2c87314610146578063715018a61461015e57806377072bf0146101755780637db3a9461461018a5780638da5cb5b1461019f578063a54f4e44146101b4578063a9d75b2b146101e0578063c1d92e67146101f5578063c7579c881461020d578063f2fde38b14610225575b600080fd5b3480156100d557600080fd5b506100de610253565b60408051918252519081900360200190f35b3480156100fc57600080fd5b50610108600435610258565b6040805173ffffffffffffffffffffffffffffffffffffffff9092168252519081900360200190f35b34801561013d57600080fd5b5061010861028d565b34801561015257600080fd5b506100de6004356102a9565b34801561016a57600080fd5b506101736102c8565b005b34801561018157600080fd5b5061017361034e565b34801561019657600080fd5b5061010861096f565b3480156101ab57600080fd5b5061010861098b565b3480156101c057600080fd5b5061017360246004803582810192908201359181359182019101356109a7565b3480156101ec57600080fd5b50610108610ab7565b34801561020157600080fd5b50610108600435610ad3565b34801561021957600080fd5b506100de600435610ae1565b34801561023157600080fd5b5061017373ffffffffffffffffffffffffffffffffffffffff60043516610aef565b600a81565b600380548290811061026657fe5b60009182526020909120015473ffffffffffffffffffffffffffffffffffffffff16905081565b60065473ffffffffffffffffffffffffffffffffffffffff1681565b60048054829081106102b757fe5b600091825260209091200154905081565b60005473ffffffffffffffffffffffffffffffffffffffff1633146102ec57600080fd5b6000805460405173ffffffffffffffffffffffffffffffffffffffff909116917ff8df31144d9c2f0f6b59d69b8b98abd5459d07f2742c4df920b25aae33c6482091a26000805473ffffffffffffffffffffffffffffffffffffffff19169055565b600080808080808080805b60025489101561093b57600280548a90811061037157fe5b6000918252602082200154600154604080517fb86472b100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff938416600482018190528251909d50929093169363b86472b19360248082019492918390030190829087803b1580156103f357600080fd5b505af1158015610407573d6000803e3d6000fd5b505050506040513d604081101561041d57600080fd5b5060200151600154604080517f221ce7c300000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8c81166004830152602482018590529151939a5091169163221ce7c3916044808201926080929091908290030181600087803b1580156104a057600080fd5b505af11580156104b4573d6000803e3d6000fd5b505050506040513d60808110156104ca57600080fd5b5080516020820151604083015160609093015160038054939a509198509296509194508a9081106104f757fe5b60009182526020909120015473ffffffffffffffffffffffffffffffffffffffff8781169116146105af57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602560248201527f4552524f523a20436f6c6c61746572616c20746f6b656e7320646f206e6f742060448201527f6d61746368000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b6006546007546004805473ffffffffffffffffffffffffffffffffffffffff93841693638c86f1e4931691908d9081106105e557fe5b9060005260206000200154896040518463ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018381526020018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019350505050602060405180830381600087803b1580156106a957600080fd5b505af11580156106bd573d6000803e3d6000fd5b505050506040513d60208110156106d357600080fd5b50516006546007546005805493955073ffffffffffffffffffffffffffffffffffffffff92831693638c86f1e493909216918d90811061070f57fe5b9060005260206000200154896040518463ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018381526020018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019350505050602060405180830381600087803b1580156107d357600080fd5b505af11580156107e7573d6000803e3d6000fd5b505050506040513d60208110156107fd57600080fd5b5051905083821415806108105750808314155b151561087d57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f4552524f523a204e6f20757064617465206e6565646564000000000000000000604482015290519081900360640190fd5b600154604080517f079239d400000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8b81166004830152898116602483015267ffffffffffffffff8916604483015260648201869052608482018590529151919092169163079239d49160a480830192600092919082900301818387803b15801561091757600080fd5b505af115801561092b573d6000803e3d6000fd5b50506001909a0199506103599050565b6040517f64ce29450ac1dca47339b74b17eeeaa0cdcd6143c5939f0a88b6cf5a68fa4fb990600090a1505050505050505050565b60015473ffffffffffffffffffffffffffffffffffffffff1681565b60005473ffffffffffffffffffffffffffffffffffffffff1681565b60005473ffffffffffffffffffffffffffffffffffffffff1633146109cb57600080fd5b82811480156109db575060045483145b1515610a6e57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f4552524f523a20496e636f6e73697374656e746c792073697a6564206172726160448201527f7973000000000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b610a7a60048585610bc3565b50610a8760058383610bc3565b506040517faad32b5df501118451f5325ab53c78d234bc6fb8e9e4e2ca0515e6784e09820f90600090a150505050565b60075473ffffffffffffffffffffffffffffffffffffffff1681565b600280548290811061026657fe5b60058054829081106102b757fe5b60005473ffffffffffffffffffffffffffffffffffffffff163314610b1357600080fd5b610b1c81610b1f565b50565b73ffffffffffffffffffffffffffffffffffffffff81161515610b4157600080fd5b6000805460405173ffffffffffffffffffffffffffffffffffffffff808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a36000805473ffffffffffffffffffffffffffffffffffffffff191673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b828054828255906000526020600020908101928215610bfe579160200282015b82811115610bfe578235825591602001919060010190610be3565b50610c0a929150610c0e565b5090565b610c2891905b80821115610c0a5760008155600101610c14565b905600a165627a7a7230582056e47ca7cfb2ec27e4c1964713d88a48ab022a46b5c2dcf7d0f4b50c5fab86020029a165627a7a7230582021d4375a25d27b9803407adf9c98d32048935dee057f62a5d0894dcb6dae7ee10029",
  "devdoc": {
    "methods": {}
  },
  "userdoc": {
    "methods": {}
  }
}